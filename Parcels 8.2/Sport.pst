<?xml version="1.0"?><st-source><!-- Name: SportNotice: ©Bruce Badger 2004-2008Sport was written by Bruce Badger of OpenSkills, with additional contributions to the VisualWorks codebase from Janko Mivsec of Eranova and Ken Treis of Miriam technology.  In 2014, they permitted the VisualWorks codebase of Sport to be made available under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.BundleName: SportBundleStructure: a Store.BundleForParcelComment: This bundle represents the deployable state of the Smalltalk portability library used for the PostgreSQL library, Hyper and OpenSkills systems.  See the comments on the sub-pundles for further details.DevelopmentPrerequisites: #(#(#any 'MD5' '') #(#any 'Protocols-Common' ''))Parcel: nilParcelName: SportPrerequisiteDescriptions: #(#(#name 'MD5') #(#name 'Protocols-Common' #componentType #package))PrerequisiteParcels: #(#('MD5' '') #('Protocols-Common' '') #('MD5' '') #('Protocols-Common' ''))Version: 3 020 - 1Date: 12:03:09 PM August 8, 2014 --><time-stamp>From VisualWorks®, Pre-Release 8.0 (jul14.2) of July 18, 2014 on August 8, 2014 at 12:03:09 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SpAbstractError</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpExceptions</category><attributes><package>SpExceptions</package></attributes></class><class><name>SpEnvironmentalCodeForGemStone</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpEnvironmental</category><attributes><package>SpEnvironmental</package></attributes></class><comment><class-id>SpEnvironmentalCodeForGemStone</class-id><body>SpEnvironmentalCodeForGemStone exists solely to hold the GemStone equivalent implementations.</body></comment><class><name>SpAbstractSocketReadRequest</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socket isComplete </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>SpSockets</package></attributes></class><class><name>SpNonBlockingSocketReadRequest</name><environment>Smalltalk</environment><super>SpAbstractSocketReadRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>SpSockets</package></attributes></class><class><name>SpUserApplication</name><environment>Smalltalk</environment><super>Core.UserApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SpSockets</package></attributes></class><comment><class-id>SpUserApplication</class-id><body>SpUserApplication exists only to perform initialisation on image start.  c.f. setUp</body></comment><class><name>SpTranscript</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpEnvironmental</category><attributes><package>SpEnvironmental</package></attributes></class><comment><class-id>SpTranscript</class-id><body>OSkTranscript is a portable transcript.  It will try to do the right thing in VW, GemStone or anywhere else.</body></comment><class><name>SpTimestamp</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingTimestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpTimes</category><attributes><package>SpTimes</package></attributes></class><class><name>SpError</name><environment>Smalltalk</environment><super>SpAbstractError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpExceptions</category><attributes><package>SpExceptions</package></attributes></class><class><name>SpSocketError</name><environment>Smalltalk</environment><super>SpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpSockets</category><attributes><package>SpSockets</package></attributes></class><class><name>SpSocketShutDownByPeer</name><environment>Smalltalk</environment><super>SpSocketError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpSockets</category><attributes><package>SpSockets</package></attributes></class><class><name>SpSocketsCodeForGemStone</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpSockets</category><attributes><package>SpSockets</package></attributes></class><class><name>SpSocketsCodeForSqueak</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpSockets</category><attributes><package>SpSockets</package></attributes></class><class><name>SpFilesCodeForGemStone</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpFiles</category><attributes><package>SpFiles</package></attributes></class><class><name>SpSocket</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>communicationDomain socketType protocolNumber underlyingSocket sumOfStalledTime stalledTimeCeiling activeReadRequest </inst-vars><class-inst-vars>addressFamilies protocolFamilies socketTypes socketOptionLevels socketOptions fileControlOptions </class-inst-vars><imports></imports><category>SpSockets</category><attributes><package>SpSockets</package></attributes></class><comment><class-id>SpSocket</class-id><body>OSkSocket  instances represent BSD sockets.  The idea here is to stick as closely to the BSD (Posix) spec terminology as possible.  I've cheated and taken the Linux man pages as being a good description of BSD sockets, and all the names etc are taken from the linux man pages (start with man socket).The key steps in using a BSD socket for a server is:	o int socket(int domain, int type, int protocol) [see: man socket]		- create a new instance of a socket  where domain is the protocol		 family (see below), type is the communication semantics (see below)		 and protocol is a specific protocol (though there is usually only one		 protocol for a given domain/type combination).		 See: OSkSocket class&gt;&gt;forDomain:type:protocol:	o  int  bind(int  sockfd, struct sockaddr *my_addr, socklen_t addrlen) [see: man bind]		- let the socket know what address it is representing.  sockfd is the id of 		 the socket, sockaddr is the address to be represented and addrlen is 		 the length in bytes of the address. 		 See OSkSocket&gt;&gt;bindSocketAddress: 	o int listen(int s, int backlog) [see: man listen]		- have the socket s listen for inbound requests, and allow up to backlog		 requests to be queued at any one time.		 See OSkSocket&gt;&gt;listenBackloggingUpTo: 	o  int   accept(int   s,  struct  sockaddr  *addr,  socklen_t *addrlen) [see: man accept]		- accept the next inbound request from the backlog.  Accept the request from		 socket s, and spawn a new socket to handle the request (freeing s to accept		 the next accept).  The new socket if defined in sockaddr which has a length of		 addrlen..		 See OSkSocket&gt;&gt;acceptFor sockets connecting to existing server sockets, the steps are"	o socket() [as above]	o  int  connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen)		- Have socket sockfd connect to the remote socket at serv_addr (where serv_addr		 is addrlen bytes long).  		 See OSkSocket&gt;&gt;connectTo:A socket appears in many ways to be a file descriptor, and the regular read and write operations can be used once a socket is open.  Accordingly, some of the file control (man fcntl) options can be used.  Of particular interest is the idea of blocking and non-blocking operation.Blocking is the default mode for an active socket.  This means that (for example) when reading from a socket the entire process(!) blocks waiting for the read operation to complete.  In non-blocking mode the same read operation would return immediately, but might not return anything useful.See man accept for more information on blocking/non-blocking.So, roughly speaking, blocking is easier to program for because you code as if the read always gets something.  A blocking interface is harder because you have to check if you got something, and try again later if you didn't - but non-blocking lets the process get on with other things while your thread is waiting, and this can be a Very Good Thing.Now, VisualWorks seems to interpret blocking to be per Smalltalk Process.  To make this work, the VisualWorks socket implementation always asks the operating system for non-blocking sockets, but presents these as approproate (blocking or non-blocking) to the Smalltalk Process.  This means that work can continue in a VisualWorks VM even when a socket is being used in (apparantly) blocking mode.A GemStone Gem asks the operating system for the kind of socket asked for by the Process.  So, if a request is made for a blocking socket, the entire Gem blocks on reads from that socket. Just beware the difference between blocking and non-blocking sockets, and also of the differing implemenmtations between Smalltalk dialects.</body></comment><class><name>SpUDPSocket</name><environment>Smalltalk</environment><super>SpSocket</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpSockets</category><attributes><package>SpSockets</package></attributes></class><class><name>SpMD5Digest</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>currentMD5Class </class-inst-vars><imports></imports><category>SpEnvironmental</category><attributes><package>SpEnvironmental</package></attributes></class><class><name>SpFilesCodeForSqueak</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpFiles</category><attributes><package>SpFiles</package></attributes></class><class><name>SpTimesCodeForGemStone</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpTimes</category><attributes><package>SpTimes</package></attributes></class><class><name>SpEnvironment</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>imageShutdownTaskBlocks </class-inst-vars><imports></imports><category>SpEnvironmental</category><attributes><package>SpEnvironmental</package></attributes></class><comment><class-id>SpEnvironment</class-id><body>SpEnvironment is, I'm afraid, a grab-bag of utility functions which didn't have a home.</body></comment><class><name>SpFilename</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingFilename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpFiles</category><attributes><package>SpFiles</package></attributes></class><class><name>SpExceptionCodeForSqueak</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpExceptions</category><attributes><package>SpExceptions</package></attributes></class><class><name>SpModel</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpEnvironmental</category><attributes><package>SpEnvironmental</package></attributes></class><class><name>SpSocketAddress</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpSockets</category><attributes><package>SpSockets</package></attributes></class><class><name>SpIPAddress</name><environment>Smalltalk</environment><super>SpSocketAddress</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hostAddress portNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpSockets</category><attributes><package>SpSockets</package></attributes></class><class><name>SpNonBlockingSocketReadRequestPostCake</name><environment>Smalltalk</environment><super>SpNonBlockingSocketReadRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>SpSockets</package></attributes></class><class><name>SpEnvironmentalCodeForSqueak</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpEnvironmental</category><attributes><package>SpEnvironmental</package></attributes></class><comment><class-id>SpEnvironmentalCodeForSqueak</class-id><body>SpEnvironmentalCodeForGemStone exists solely to hold the Squeak equivalent implementations.</body></comment><class><name>SpWeakArray</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpEnvironmental</category><attributes><package>SpEnvironmental</package></attributes></class><class><name>SpRandom</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingRandomStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpEnvironmental</category><attributes><package>SpEnvironmental</package></attributes></class><class><name>SpDate</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingDate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpTimes</category><attributes><package>SpTimes</package></attributes></class><class><name>SpHexStringError</name><environment>Smalltalk</environment><super>SpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpEnvironmental</category><attributes><package>SpEnvironmental</package></attributes></class><comment><class-id>SpHexStringError</class-id><body>If SpEnvironment has a problem with converting a ByteArray to a hex string or the reverse it raises an SpHexStringError.</body></comment><class><name>SpExceptionContext</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpExceptions</category><attributes><package>SpExceptions</package></attributes></class><comment><class-id>SpExceptionContext</class-id><body>In visual works SpExceptionContext is a no-op wrapper around the regular ANSI exception handling.  The wrapper exists so code can be written in such a way that it will run in Smalltalk dialects that do not yet implement ANSI exception handling. </body></comment><class><name>SpTimesCodeForSqueak</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpTimes</category><attributes><package>SpTimes</package></attributes></class><class><name>SpNonBlockingSocketReadRequestPreCake</name><environment>Smalltalk</environment><super>SpNonBlockingSocketReadRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>SpSockets</package></attributes></class><class><name>SpExceptionCodeForGemStone</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpExceptions</category><attributes><package>SpExceptions</package></attributes></class><class><name>SpBlockingSocketReadRequest</name><environment>Smalltalk</environment><super>SpAbstractSocketReadRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>SpSockets</package></attributes></class><class><name>SpFileStream</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingStream filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpFiles</category><attributes><package>SpFiles</package></attributes></class><class><name>SpStringUtilities</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpEnvironmental</category><attributes><package>SpEnvironmental</package></attributes></class><methods><class-id>SpEnvironmentalCodeForGemStone class</class-id> <category>code strings</category><body package="SpEnvironmental">codeString	"^a String	I return the string which is the source code for the GemStone compatibility classes."	"(Filename named: 'SpEnvironmental.gs') writeStream nextPutAll: self codeString; close"	^'!! From ! GEMSTONE: 6.1, Thu Apr 17 20:11:38 US/Pacific 2003; IMAGE: GemStone v6.1 kernel classes filein completed at 17/04/2003 20:22:36! GemStone v6.1 kernel classes filein of stripped sources completed at 17/04/2003 20:31:50! ! On December 24, 2008, 11:01:35 am!!! SymbolDictionary ''SpEnvironmental''!run| symList newDict |symList := System myUserProfile symbolList.symList do: [ :element |    (element includesKey: #SpEnvironmental)        ifTrue: [ ^element ]].newDict := SymbolDictionary new.newDict at: #SpEnvironmental put: newDict.System myUserProfile insertDictionary: newDict at: 1.^newDict%doit(Object subclass: ''SpEnvironment''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpEnvironmental  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''SpMD5Digest''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpEnvironmental  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''SpModel''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpEnvironmental  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''SpStringUtilities''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpEnvironmental  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''SpTranscript''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpEnvironmental  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''SpWeakArray''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpEnvironmental  constraints: #[]  instancesInvariant: false  isModifiable: true).%doitSpEnvironment immediateInvariant.%doitSpMD5Digest immediateInvariant.%doitSpModel immediateInvariant.%doitSpStringUtilities immediateInvariant.%doitSpTranscript immediateInvariant.%doitSpWeakArray immediateInvariant.%! Remove existing behavior from SpEnvironmentdoitSpEnvironment removeAllMethods.SpEnvironment class removeAllMethods.%! ------------------- Class methods for SpEnvironmentcategory: ''compiling''classmethod: SpEnvironmentevaluate: aString in: anEnvironment"This is a no-op for now since nothing in practice has needed it in GemStone."	^self%category: ''compiling''classmethod: SpEnvironmentevaluate: aString receiver: anObject in: anEnvironment "This is a no-op for now since nothing in practice has needed it in GemStone."	^self%category: ''development''classmethod: SpEnvironmentmadeObsoleteBy: aBlock 	"^an ObjectI cause halt the code and ask the developer to use the code in aBlock, rather than the obsolete code."	(self isHeadless or: [self isGemStone]) 		ifFalse: 			[1 				halt: ''please use the code in the block, not the obsolete code - thanks.''].	^aBlock value%category: ''development''classmethod: SpEnvironmentworkInProgress	"^selfThis method does nothing, but can be used to ''mark'' methods still needing work.  Simply send this message, and use browse senders to find things still in need of attention."	^self%category: ''hex''classmethod: SpEnvironmentbyteArrayFromHexString: aString 	| sourceString sourceStream targetStream |	sourceString := (aString size \\ 2) == 0 				ifTrue: [aString]				ifFalse: [''0'' , aString].	sourceStream := ReadStream on: sourceString.	targetStream := WriteStream on: (ByteArray new: sourceString size / 2).	[sourceStream atEnd] whileFalse: 			[targetStream nextPut: (Integer fromString: ''16r'' , (sourceStream next: 2))].	^targetStream contents%category: ''hex''classmethod: SpEnvironmenthexStringFromByteArray: aByteArray 	^aByteArray asHexString%category: ''image shutdown''classmethod: SpEnvironmentaddImageShutdownTask: aBlock for: anObject 	"^self	This is a no-op in GemStone"	^self%category: ''image shutdown''classmethod: SpEnvironmentremoveShutdownActionFor: anObject 	"^self	This is a no-op in GemStone"	^self%category: ''os commands''classmethod: SpEnvironmentrunShellCommandString: aCommandString 	^System performOnServer: aCommandString%category: ''queries''classmethod: SpEnvironmentallSubclassesOf: aClass"^an ArrayI return the array of classes which are subclasses of aClass."	^ClassOrganizer new allSubclassesOf: aClass%category: ''services''classmethod: SpEnvironmentassociationWithKey: aKey value: aValue	^Association newWithKey: aKey value: aValue%category: ''services''classmethod: SpEnvironmentcharacterFromInteger: anInteger 	^Character withValue: anInteger%category: ''services''classmethod: SpEnvironmentintegerFromString: aString 	"^an IntegerWe need this because of what looks like a bug in GemStone''s String&gt;&gt;asNumber (e.g. ''16rFF'' -&gt; 1.6000000000000000E+01, not 255).  Also, fromString: requires that aString not have any leading alphabetic characters.Oh, and note the stupid fix for GemStone reseting the stream to the begining after doing an upToEnd.""SpEnvironment integerFromString: ''ubuntu''" 	| rawStream cleanedString |	rawStream := ReadStream on: aString.	cleanedString := ''0''.	[rawStream atEnd] whileFalse: 			[rawStream peek isDigit 				ifTrue: [cleanedString := rawStream upToEnd.						rawStream position: aString size; next. ]				ifFalse: [rawStream next]].	^Integer fromString: cleanedString%category: ''services''classmethod: SpEnvironmentreadIntegerFrom: aStream radix: aRadix 	"^an Integer"	^Integer readFrom: aStream base: aRadix%category: ''services''classmethod: SpEnvironmentstreamStartPosition	"^an IntegerStreams start at position 0 in VisualWorks, and position 1 in GemStone(!)."	^1%category: ''services''classmethod: SpEnvironmentwriteStackDumpForException: anException context: aContext to: targetStream 	targetStream nextPutAll: (GsProcess stackReportToLevel: 50).	^self%category: ''testing''classmethod: SpEnvironmentisGemStone	^true%category: ''testing''classmethod: SpEnvironmentisHeadless	^true%category: ''testing''classmethod: SpEnvironmentisVisualWorks	^false%! ------------------- Instance methods for SpEnvironment! Remove existing behavior from SpMD5DigestdoitSpMD5Digest removeAllMethods.SpMD5Digest class removeAllMethods.%! ------------------- Class methods for SpMD5Digest! ------------------- Instance methods for SpMD5Digest! Remove existing behavior from SpModeldoitSpModel removeAllMethods.SpModel class removeAllMethods.%! ------------------- Class methods for SpModel! ------------------- Instance methods for SpModel! Remove existing behavior from SpStringUtilitiesdoitSpStringUtilities removeAllMethods.SpStringUtilities class removeAllMethods.%! ------------------- Class methods for SpStringUtilitiescategory: ''services''classmethod: SpStringUtilitiesbytesAsString: aByteArray	"^a StringNo encoding in GemStone ... yet."	" SpStringUtilities bytesAsString: #(72 101 108 108 111 44 32 87 111 114 108 100 46) "	| targetString |	targetString := String new: aByteArray size.	1 to: aByteArray size		do: [:index | targetString at: index put: (Character withValue: (aByteArray at: index))].	^targetString%category: ''services''classmethod: SpStringUtilitiesprevIndexOf: anElement from: startIndex to: stopIndex in: aString	"Answer the previous index of anElement within the receiver between startIndex and stopIndex	 working backwards through the receiver.  If the receiver does not contain anElement, answer nil"	startIndex to: stopIndex by: -1 do:		[:i |		(aString at: i) = anElement			ifTrue: [^i]].	^nil%category: ''services''classmethod: SpStringUtilitiestokensBasedOn: separatorString in: aString 	"Answer an OrderedCollection of the sub-sequences	 of the receiver that are separated by anObject."	| result lastIdx idx lastToken |	result := OrderedCollection new.	lastIdx := 0.		[idx := aString findString: separatorString startingAt: lastIdx + 1.	idx &gt; 0] 			whileTrue: 				[idx == (lastIdx + 1)					ifTrue: [result addLast: String new]					ifFalse: [result addLast: (aString copyFrom: lastIdx + 1 to: idx - 1)].				lastIdx := idx].	lastToken := lastIdx = aString size 				ifTrue: [String new]				ifFalse: [aString copyFrom: lastIdx + 1 to: aString size].	result addLast: lastToken.	^result%category: ''services''classmethod: SpStringUtilitiestrimBlanksFrom: aString 	"^a StringI return a copy of aString with all leading and trailing blanks removed."	| first last |	first := 1.	last := aString size.	[last &gt; 0 and: [(aString at: last) isSeparator]] 		whileTrue: [last := last - 1].	^last == 0 		ifTrue: [String new]		ifFalse: 			[[first &lt; last and: [(aString at: first) isSeparator]] 				whileTrue: [first := first + 1].			aString copyFrom: first to: last]%category: ''services-encoding''classmethod: SpStringUtilitiesbytes: subjectBytes asStringUsingEncodingNames: anEncodingName 	"^a StringNo encoding in GemStone ... yet."	^self bytesAsString: subjectBytes%category: ''services-encoding''classmethod: SpStringUtilitiesstring: subjectString asBytesUsingEncodingNamed: anEncodingName "^a ByteArray No encoding in GemStone ... yet."	^subjectString asByteArray%category: ''services-encoding''classmethod: SpStringUtilitiesstringFromBytes: aByteArray 	"^a StringIn GemStone [''Hello, World'' asByteArray asString] returns the string ''aByteArray'' !This is the boring long way of getting a string from a ByteArray - but it does workin GemStone."	"HTTPString stringFromBytes: (''Hello, World'' asByteArray)"	| targetStream |	targetStream := WriteStream on: String new.	aByteArray do: [:aByte | targetStream nextPut: aByte asCharacter].	^targetStream contents%! ------------------- Instance methods for SpStringUtilities! Remove existing behavior from SpTranscriptdoitSpTranscript removeAllMethods.SpTranscript class removeAllMethods.%! ------------------- Class methods for SpTranscriptcategory: ''logging''classmethod: SpTranscriptcr"^selfThis is a no-op for now."	^self%category: ''logging''classmethod: SpTranscriptnextPut: anObject 	^self show: (String with: anObject)%category: ''logging''classmethod: SpTranscriptnextPutAll: aCollection 	^self show: aCollection%category: ''logging''classmethod: SpTranscriptshow: aString "^selfThis is a no-op for now."	^self%! ------------------- Instance methods for SpTranscript! Remove existing behavior from SpWeakArraydoitSpWeakArray removeAllMethods.SpWeakArray class removeAllMethods.%! ------------------- Class methods for SpWeakArraycategory: ''instance creation''classmethod: SpWeakArraynew: anInteger 	"^a WeakArray 	I don''t return an instance of myself, I return an Array -  until I can think of a better GemStone alternative."	^Array new: anInteger%category: ''instance creation''classmethod: SpWeakArraywithAll: aCollection 	"^a WeakArray 	I don''t return an instance of myself at all. I return an Array -  until I can think of a better GemStone alternative."	^Array withAll: aCollection%! ------------------- Instance methods for SpWeakArray'</body></methods><methods><class-id>SpAbstractSocketReadRequest</class-id> <category>services</category><body package="SpSockets">doThenComplete: aBlock 	"^an ObjectI evaluate aBlock and return the result.  I ensure that I mark myself as complete when the block finishes."	^aBlock ensure: [isComplete := true]</body><body package="SpSockets">underlyingSocket	"^a SocketAccessorI return the socket accessor for my client socket."	^self socket underlyingSocket</body></methods><methods><class-id>SpAbstractSocketReadRequest</class-id> <category>initialize-release</category><body package="SpSockets">for: anSpSocket 	"^a SocketReadRequest of some kindIf anSpSocket already has an outstanding read request I throw an exception, otherwise I create the new instance and return it."	socket := anSpSocket.	^self</body></methods><methods><class-id>SpAbstractSocketReadRequest</class-id> <category>testing</category><body package="SpSockets">isComplete	"^a BooleanI return true if I am complete, otherwise false."	isComplete isNil ifTrue: [isComplete := false].	^isComplete</body></methods><methods><class-id>SpAbstractSocketReadRequest</class-id> <category>accessing</category><body package="SpSockets">socket	"^an SpSocketI return the socket from which I am trying to read octets."	^socket</body></methods><methods><class-id>SpAbstractSocketReadRequest class</class-id> <category>initialize-release</category><body package="SpSockets">concreteClassFor: anSpSocket	"^a ClassI return the class I really want to make an instance of.  By default that will be self, but my subclasses may override."	^self</body><body package="SpSockets">for: anSpSocket 	"^a SocketReadRequest of some kindIf anSpSocket already has an outstanding read request I throw an exception, otherwise I create the new instance and return it."	anSpSocket activeReadRequest notNil 		ifTrue: 			[SpSocketError 				raiseSignal: 'Read request made while another request is active.'].	^(self concreteClassFor: anSpSocket) new for: anSpSocket</body></methods><methods><class-id>SpNonBlockingSocketReadRequest</class-id> <category>services-io</category><body package="SpSockets">recvInto: aByteArray startingAt: startIndex for: aNumberOfOctets 	^self subclassResponsibility</body><body package="SpSockets">waitForNonBlockingReadActivityUpToMs: aNumberOfMilliseconds 	"^a BooleanI return true if there has been some read related activity on my underlying socket, otherwise false.  Note that activity may not mean that data is available.  It may just mean that the socket is in a new (perhaps error) state."	^self doThenComplete: 			[(self underlyingSocket readWaitWithTimeoutMs: aNumberOfMilliseconds) not]</body></methods><methods><class-id>SpNonBlockingSocketReadRequest class</class-id> <category>initialize-release</category><body package="SpSockets">concreteClassFor: anSpSocket 	"^a ClassI return the class I really want to make an instance of.  By default that will be self, but my subclasses may override."	^(anSpSocket underlyingSocket 		respondsTo: #primReadOrErrorCodeInto:startingAt:for:) 			ifTrue: [SpNonBlockingSocketReadRequestPostCake]			ifFalse: [SpNonBlockingSocketReadRequestPreCake]</body></methods><methods><class-id>SpUserApplication</class-id> <category>actions</category><body package="SpSockets">setUp	"^selfIf an image uses SpSocket and is then saved and re-started on a different kind of platform (e.g. Linux -&gt; Windows), the default settings in SpSocket will be wrong.   Here we initialise all the settings on image start, just to be sure.Problem found and fixes by user clw.  Many thanks."	super setUp.	SpSocket initialize.	SpUDPSocket initialize.	^self</body></methods><methods><class-id>SpTranscript class</class-id> <category>logging</category><body package="SpEnvironmental">cr	^SpEnvironment isHeadless ifTrue: [self] ifFalse: [Transcript cr]</body><body package="SpEnvironmental">nextPut: anObject 	^self show: (String with: anObject)</body><body package="SpEnvironmental">nextPutAll: aCollection 	^self show: aCollection</body><body package="SpEnvironmental">show: aString 	^SpEnvironment isHeadless 		ifTrue: [self]		ifFalse: [Transcript show: aString]</body></methods><methods><class-id>SpTimestamp</class-id> <category>comparing</category><body package="SpTimes">&lt;= anOSkTimeStamp 	^self underlyingTimestamp &lt;= anOSkTimeStamp underlyingTimestamp</body><body package="SpTimes">= anOSkTimeStamp^self underlyingTimestamp = anOSkTimeStamp underlyingTimestamp</body><body package="SpTimes">&gt; anOSkTimeStamp^self underlyingTimestamp &gt; anOSkTimeStamp underlyingTimestamp</body><body package="SpTimes">hash	^self underlyingTimestamp hash</body></methods><methods><class-id>SpTimestamp</class-id> <category>private</category><body package="SpTimes">underlyingTimestamp	^underlyingTimestamp</body></methods><methods><class-id>SpTimestamp</class-id> <category>initialize-release</category><body package="SpTimes">asNowUTC	"^selfCheat for now and assumen that Timestamp&gt;&gt;now is UTC."	underlyingTimestamp := Timestamp now.	^self</body><body package="SpTimes">fromDate: aDate andTime: aTime 	"^selfInitialize myself on the basis of aDate and aTime."	underlyingTimestamp := Timestamp fromDate: aDate andTime: aTime.	^self</body><body package="SpTimes">fromSeconds: anInteger 	"^an OSkTimestampI return an instance of myself that represents anInteger number of seconds since January 1, 1901 0:00:00.000.  BTW, negative values of anInteger are fine."	underlyingTimestamp := Timestamp fromSeconds: anInteger.	^self</body></methods><methods><class-id>SpTimestamp</class-id> <category>services</category><body package="SpTimes">asRFC1123String	"^a String	c.f  &gt;&gt;asRFC1123StringOn: "	| targetStream |	targetStream := String new writeStream.	self asRFC1123StringOn: targetStream.	^targetStream contents</body><body package="SpTimes">asRFC1123StringOn: targetStream	"^self	Code taken from Swazoo Timestamp extenton with the following comment:	FIXME: Assumes server's clock is GMT.  Should convert server's clock to GMT if it is not.  Besides that, this whole method is really ugly."	targetStream nextPutAll: (self underlyingTimestamp asDate weekday copyFrom: 1 to: 3);	nextPutAll: ', '.	self underlyingTimestamp day &lt; 10 ifTrue: [targetStream nextPut: $0].	self underlyingTimestamp asDate printOn: targetStream format: #(1 2 3 $  2 1).	targetStream space.	self underlyingTimestamp hour 		printOn: targetStream		paddedWith: $0		to: 2		base: 10.	targetStream nextPut: $:.	self underlyingTimestamp minute 		printOn: targetStream		paddedWith: $0		to: 2		base: 10.	targetStream nextPut: $:.	self underlyingTimestamp second 		printOn: targetStream		paddedWith: $0		to: 2		base: 10.	targetStream nextPutAll: ' GMT'.	^self</body><body package="SpTimes">asSeconds	"^an IntegerI return the timestamp as a number of seconds."	^self underlyingTimestamp asSeconds</body><body package="SpTimes">date	"^an SpDateI return an instance of SpDate for the date I represent."		^SpDate onDate: self underlyingTimestamp asDate</body></methods><methods><class-id>SpTimestamp class</class-id> <category>instance creation</category><body package="SpTimes">fromDate: aDate andTime: aTime 	^self new fromDate: aDate andTime: aTime</body><body package="SpTimes">fromRFC1123String: aString 	"^an OpTimestampNote that the full format of the string is 'DDD, dd mmm yyyy hh:mm:ss'.  For example 'Sun, 27 May 2007 13:08:36'.  Since the DDD (day name) is redudant information I just ignore it."	"SpTimestamp fromRFC1123String: 'Sun, 27 May 2007 13:08:36' "	| sourceStream dd mmm yyyy time |	^SpExceptionContext for: 			[sourceStream := ReadStream on: aString.			sourceStream upTo: $,.			sourceStream atEnd 				ifTrue: [sourceStream reset]				ifFalse: [[sourceStream peek isSeparator] whileTrue: [sourceStream next]].			dd := sourceStream upTo: Character space.			mmm := sourceStream upTo: Character space.			yyyy := sourceStream upTo: Character space.			time := sourceStream upTo: Character space.			self fromDate: (Date 						newDay: dd asNumber						month: mmm						year: yyyy asNumber)				andTime: (Time readFrom: (ReadStream on: time))]		onAnyExceptionDo: 			[:exception | 			SpError raiseSignal: 'Error parsing RFC1123 date: ' , aString]</body><body package="SpTimes">fromSeconds: anInteger 	"^an OSkTimestampI return an instance of myself that represents anInteger number of seconds since ..."	^self new fromSeconds: anInteger</body><body package="SpTimes">now	"^an OSkTimestamp	I return a new instance of myself which represents the time now in the	UTC (GMT ish) time zone."	^self new asNowUTC</body></methods><methods><class-id>SpSocketsCodeForGemStone class</class-id> <category>code strings</category><body package="SpSockets">codeString	"^a String	I return the string which is the source code for the OpenSkills GemStone sockets classes."	"(Filename named: 'SpSockets.gs') writeStream nextPutAll: self codeString; close"	^'!! From ! GEMSTONE: 6.1, Thu Apr 17 20:11:38 US/Pacific 2003; IMAGE: GemStone v6.1 kernel classes filein completed at 17/04/2003 20:22:36! GemStone v6.1 kernel classes filein of stripped sources completed at 17/04/2003 20:31:50! ! On January 26, 2009, 12:13:14 am!!! SymbolDictionary ''SpSockets''!run| symList newDict |symList := System myUserProfile symbolList.symList do: [ :element |    (element includesKey: #SpSockets)        ifTrue: [ ^element ]].newDict := SymbolDictionary new.newDict at: #SpSockets put: newDict.System myUserProfile insertDictionary: newDict at: 1.^newDict%doit(SpError subclass: ''SpSocketError''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpSockets  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(SpSocketError subclass: ''SpSocketShutDownByPeer''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpSockets  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''SpSocket''  instVarNames: #( communicationDomain socketType protocolNumber                    underlyingSocket)  classVars: #()  classInstVars: #( addressFamilies protocolFamilies socketTypes socketOptionLevels socketOptions fileControlOptions)  poolDictionaries: #[]  inDictionary: SpSockets  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''SpSocketAddress''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpSockets  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(SpSocketAddress subclass: ''SpIPAddress''  instVarNames: #( hostAddress portNumber)  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpSockets  constraints: #[]  instancesInvariant: false  isModifiable: true).%doitSpSocketError immediateInvariant.%doitSpSocketShutDownByPeer immediateInvariant.%doitSpSocket immediateInvariant.%doitSpSocketAddress immediateInvariant.%doitSpIPAddress immediateInvariant.%! Remove existing behavior from SpSocketErrordoitSpSocketError removeAllMethods.SpSocketError class removeAllMethods.%! ------------------- Class methods for SpSocketError! ------------------- Instance methods for SpSocketError! Remove existing behavior from SpSocketShutDownByPeerdoitSpSocketShutDownByPeer removeAllMethods.SpSocketShutDownByPeer class removeAllMethods.%! ------------------- Class methods for SpSocketShutDownByPeer! ------------------- Instance methods for SpSocketShutDownByPeer! Remove existing behavior from SpSocketdoitSpSocket removeAllMethods.SpSocket class removeAllMethods.%! ------------------- Class methods for SpSocketcategory: ''defined symbols''classmethod: SpSocketaddressFamilies	"^an IdentityDictionary	I return the dictionary mapping each defined address family symbol to it''s numeric	value.  See socket.h and look for the #def AF_xxx lines.	If you modify this method, evaluate the following:		''SpSocket resetAllDefinedValues'' "	addressFamilies isNil 		ifTrue: 			[addressFamilies := (IdentityDictionary new)						at: #AF_UNIX put: 1;						at: #AF_LOCAL put: 1;						at: #AF_INET put: 2;						yourself].	^addressFamilies%category: ''defined symbols''classmethod: SpSocketfileControlOptions	"^an IdentityDictionary	I return the dictionary mapping each defined file control symbol to it''s numeric	value.  See fcntl.h and look for the at: #O_xxx lines.	Really this is here for the O_NONBLOCK option which sets the fd (file descriptor)	of a socket to non-blocking mode when used in an fcntl() function.	If you modify this method, evaluate the following:		''SpSocket resetAllDefinedValues'' "	fileControlOptions isNil 		ifTrue: 			[fileControlOptions := (IdentityDictionary new)						at: #O_ACCMODE put: 0003;						at: #O_RDONLY put: 00;						at: #O_WRONLY put: 01;						at: #O_RDWR put: 02;						at: #O_CREAT put: 0100;						at: #O_EXCL put: 0200;						at: #O_NOCTTY put: 0400;						at: #O_TRUNC put: 01000;						at: #O_APPEND put: 02000;						at: #O_NONBLOCK put: 04000;						at: #O_NDELAY put: 04000;						at: #O_SYNC put: 010000;						at: #FASYNC put: 020000;						at: #O_DIRECT put: 040000;						at: #O_LARGEFILE put: 0100000;						at: #O_DIRECTORY put: 0200000;						at: #O_NOFOLLOW put: 0400000;						yourself].	^fileControlOptions%category: ''defined symbols''classmethod: SpSocketprotocolFamilies	"^an IdentityDictionary	I return the dictionary mapping each defined protocol family symbol to it''s numeric	value.  See socket.h and look for the #def PF_xxx lines.	If you modify this method, evaluate the following:		''SpSocket resetAllDefinedValues'' "	protocolFamilies isNil 		ifTrue: 			[protocolFamilies := (IdentityDictionary new)						at: #PF_UNIX put: (self addressFamilies at: #AF_UNIX);						at: #PF_LOCAL put: (self addressFamilies at: #AF_LOCAL);						at: #PF_INET put: (self addressFamilies at: #AF_INET);						yourself].	^protocolFamilies%category: ''defined symbols''classmethod: SpSocketsocketOptionLevels	"^an IdentityDictionary	I return the dictionary mapping each defined socket option level symbol to it''s numeric	value.  See socket.h and look for the #define SOL_xxx lines.	If you modify this method, evaluate the following:		''SpSocket resetAllDefinedValues'' "	socketOptionLevels isNil 		ifTrue: 			[socketOptionLevels := (IdentityDictionary new)						at: #SOL_SOCKET put: 1;						yourself].	^socketOptionLevels%category: ''defined symbols''classmethod: SpSocketsocketOptions	"^an IdentityDictionary	I return the dictionary mapping each defined socket option symbol to it''s numeric	value.  See socket.h and look for the #define SO_xxx lines.	If you modify this method, evaluate the following:		''SpSocket resetAllDefinedValues'' "	socketOptions isNil 		ifTrue: 			[socketOptions := (IdentityDictionary new)						at: #SO_REUSEADDR put: 2;						yourself].	^socketOptions%category: ''defined symbols''classmethod: SpSocketsocketTypes	"^an IdentityDictionary	I return the dictionary mapping each defined socket type symbol to it''s numeric	value.  See socket.h and look for the #define SOCK_xxx lines.	If you modify this method, evaluate the following:		''SpSocket resetAllDefinedValues'' "	socketTypes isNil 		ifTrue: 			[socketTypes := (IdentityDictionary new)						at: #SOCK_STREAM put: 1;						yourself].	^socketTypes%category: ''instance creation''classmethod: SpSocketforDomain: aCommunicationsDomain type: aSocketType 	"^an SpSocket	Default the protocol to zero - this is the default  in the Spec anyway.  See man socket.."	^self 		forDomain: aCommunicationsDomain		type: aSocketType		protocol: 0%category: ''instance creation''classmethod: SpSocketforDomain: aDomainSymbol type: aSocketTypeSymbol protocol: aProtocolNumber 	"^an SpSocket	Equivalent of int socket(int domain, int type, int protocol);  see man socket.	I return a new instance of myself that represents a socket configured for the	specified domain type and protocol .	Note in GS we can''t specify any of the regular socket stuff - it''s TCP Stream only!"	| newNativeSocket |	newNativeSocket := GsSocket new.	^self new 		onNativeSocket: newNativeSocket		forDomain: aDomainSymbol		type: aSocketTypeSymbol		protocol: aProtocolNumber%category: ''instance creation''classmethod: SpSocketsocketPairForDomain: aCommunicationsDomain type: aSocketType 	"^an SpSocket	see: man socketpair	Default the protocol to zero - this is the default  in the Spec anyway. "	^self 		socketPairForDomain: aCommunicationsDomain		type: aSocketType		protocol: 0%category: ''instance creation''classmethod: SpSocketsocketPairForDomain: aDomainSymbol type: aTypeSymbol protocol: aProtocolNumber 	"^an SpSocket	See: man socketpair	Equivalent of int socketpair(int d, int type, int protocol, int sv[2]); 	I return and array containing two new instances of myself each representing	one end of a connection.	No direct way to do this in GS - I''ll look at it when I need it."	"SocketAccessor openPair collect: 			[:newNativeSocket | 			self new 				onNativeSocket: newNativeSocket				forDomain: aDomainSymbol				type: aTypeSymbol				protocol: aProtocolNumber]"	^1 halt: ''Doh! - not supported in GS''%category: ''private''classmethod: SpSocketonNativeclientSocket: aNativeSocket for: aServerSocket 	"^an SpSocketI create a new instance of my self at the request of aServerSocket  wherethis new instance will be a connected client socket (connected via aNativeSoket)."	^self new onNativeclientSocket: aNativeSocket for: aServerSocket%category: ''private''classmethod: SpSocketresetAllDefinedValues	"^self	I simply set the all the symbol dictionaries containing defined values to	nil, forcing them to be re-initialized on demand."	"SpSocket resetAllDefinedValues"	addressFamilies := nil.	protocolFamilies := nil.	socketTypes := nil.	^self%category: ''services''classmethod: SpSocketconnectToServerOnHost: hostName port: portNumber 	"^an SpSocket 	I return a new instance of myself which represents a socket connecter to a server listening on portNumber at hostName."	| newSocket |	newSocket := self newTCPSocket.	newSocket connectTo: (SpIPAddress hostName: hostName port: portNumber).	^newSocket%category: ''services''classmethod: SpSocketinitialize	^self resetAllDefinedValues%category: ''services''classmethod: SpSocketnewSocketPair	"^an Array	I return an array containing two SpSockets each representing one end of a	#PF_UNIX connection."	^self socketPairForDomain: #PF_UNIX type: #SOCK_STREAM%category: ''services''classmethod: SpSocketnewTCPSocket	"^an SpSocket	I create and return a new socket configured to be of a streaming type handle the 	IPv4 peotocol family (default protocol).  This is a tcp_socket (see man 7 ip)."	^self forDomain: #PF_INET type: #SOCK_STREAM%! ------------------- Instance methods for SpSocketcategory: ''accessing''method: SpSocketcommunicationDomain	^communicationDomain%category: ''accessing''method: SpSocketprotocolNumber	^protocolNumber%category: ''accessing''method: SpSocketsocketType	^socketType%category: ''initialize-release''method: SpSocketonNativeSocket: aSocket forDomain: aCommunicationDomain type: aSocketType protocol: aProtocolNumber 	"^self	I initialize myself as a socket defined by the communications domain, type and protocol.  This	follows the equivalent of the using the socket()  or socketpair() function."	communicationDomain := aCommunicationDomain.	socketType := aSocketType.	protocolNumber := aProtocolNumber.	underlyingSocket := aSocket.	^self%category: ''private''method: SpSocketonNativeclientSocket: aNativeSocket for: aServerSocket 	"^self	I initialize myself with the same properties as aServerSocket and with	aNativeSocket as my underlying socket."	communicationDomain := aServerSocket communicationDomain.	socketType := aServerSocket socketType.	protocolNumber := aServerSocket protocolNumber.	underlyingSocket := aNativeSocket.	^self%category: ''private''method: SpSocketunderlyingSocket	^underlyingSocket%category: ''services-accessing''method: SpSocketgetPeerName	"^an SpSocketAddress	see man getpeername.	I return the socket address of the other/remote/peer end of the socket I represent."	^SpIPAddress host: self underlyingSocket peerAddress port: self underlyingSocket peerPort%category: ''services-accessing''method: SpSocketgetSocketName	"^an SpSocketAddress	see: man getsockname	I return my local socket address which may be any subclass of 	SpSocketAddress."	^SpIPAddress host: self underlyingSocket address port: self underlyingSocket port%category: ''services-io''method: SpSocketread: targetNumberOfBytes 	"^a ByteArray	I attempt to read the targetNumberOfBytes from my underlying socket.  If the targetNumberOfBytes	are not available, I return what I can get.	Note that here I make sure that I behave in the same way as VisualWorks - i.e. I make blocking	with respect to the Smalltalk Pocess.  So if a Smalltalk process invokes this method it will block until	a read is possible - however, the other processes in the Gem will *not* block."	| targetByteArray numberOfBytesActuallyRead |	[self underlyingSocket readWillNotBlock] whileFalse: [Processor yield].	targetByteArray := ByteArray new: targetNumberOfBytes.	numberOfBytesActuallyRead := self underlyingSocket 				read: targetNumberOfBytes				into: targetByteArray.	^numberOfBytesActuallyRead &gt; 0		ifTrue: [targetByteArray copyFrom: 1 to: numberOfBytesActuallyRead]		ifFalse: [ByteArray new]%category: ''services-io''method: SpSocketreadInto: aByteArray startingAt: startIndex for: aNumberOfBytes 	"^an IntegerI return the number of bytes actually read."	^self underlyingSocket 		read: aNumberOfBytes		into: aByteArray		startingAt: startIndex%category: ''services-io''method: SpSocketreadyForRead	"^a BooleanI return true if a read operation will return some number of bytes."	^self underlyingSocket readWillNotBlock%category: ''services-io''method: SpSocketwaitForReadDataUpToMs: aNumberOfMilliseconds 	"^a Boolean	I return true if we think data became available within aNumberOfMilliseconds, and	false if we timed out."	^self underlyingSocket readWillNotBlockWithin: aNumberOfMilliseconds%category: ''services-io''method: SpSocketwrite: sourceByteArray 	"^an Integer	I write the contents of the sourceByteArray to my underlying Socket.	I return the number of bytes written."	| result |	result := self underlyingSocket write: sourceByteArray size				from: sourceByteArray.	result isNil 		ifTrue: 			[| errorMessageStream |			errorMessageStream := WriteStream on: String new.			errorMessageStream				nextPutAll: ''Error code: '';				nextPutAll: self underlyingSocket lastErrorCode printString;				nextPutAll: '', Error string: '';				nextPutAll: self underlyingSocket lastErrorString printString;				nextPutAll: '', Error symbol: '';				nextPutAll: self underlyingSocket lastErrorSymbol printString.			SpSocketError raiseSignal: errorMessageStream contents].	^result%category: ''services-io''method: SpSocketwriteFrom: aByteArray startingAt: startIndex for: length 	"^an IntegerI return the number of bytes actually written.  A GemStone socket may return nil.  This indicates that an error of some kind has occured."	| result |	result := self underlyingSocket 				write: length				from: aByteArray				startingAt: startIndex.	result isNil 		ifTrue: 			[SpSocketError raiseSignal: ''Unexpected and unknown socket error occured.''].	^result%category: ''services-io non-blocking''method: SpSocketrecvWithoutBlockingInto: aByteArray startingAt: startIndex for: aNumberOfOctets 	"^an IntegerThis implements recv() per http://linux.die.net/man/2/recv as closely a possible.  i.e. recv(int s, void *buf, size_t len, int flags) except for flags.  s is me (self), a connected socket.  *buf and len are a combination of aByteArray, startIndex and aNumberOfOctets (since *buf may point to the current start point in a larger buffer)."	| clearToRecv |	(clearToRecv := self underlyingSocket readWillNotBlock) == nil 		ifTrue: 			[^SpSocketError raiseSignal: ''Socket recv error: '' GsSocket lastErrorString].	^clearToRecv 		ifTrue: 			["since read will not block, it''s okay to make the blocking read call"			self 				readInto: aByteArray				startingAt: startIndex				for: aNumberOfOctets]		ifFalse: [0]%category: ''services-io non-blocking''method: SpSocketwaitForNonBlockingReadActivityUpToMs: aNumberOfMilliseconds 	"^a BooleanI return true if there has been some read related activity on my underlying socket, otherwise false.  Note that activity may not mean that data is available.  It may just mean that the socket is in a new (perhaps error) state."	| activityBoolean |	activityBoolean := self underlyingSocket 				readWillNotBlockWithin: aNumberOfMilliseconds.	^activityBoolean == nil or: [activityBoolean]%category: ''services-options''method: SpSocketsetAddressReuse: aBoolean 	"^self	c.f. self class &gt;&gt;socketOptions and self &gt;&gt;setOptionForLevel:optionID:value:	If a boolean is true, I set address reuse on, otherwise I set address reuse off."	^self underlyingSocket option: ''REUSEADDR'' put: aBoolean%category: ''services-status''method: SpSocketaccept	"^an SpSocket	I accept the next connection made to the server socket I represent.  I return a new	instance of SpSocket which represents the socket over which information can be	exchanged.	NOTE: this call will block waiting for an inbound connection"	^SpSocket onNativeclientSocket: (self underlyingSocket accept) for: self%category: ''services-status''method: SpSocketacceptRetryingIfTransientErrors	"^an SpSocket	I try to do an accept.  If I get an exception which is ''transient'' I retry.	... except that in GemStone, I don''t do that - because I don''t know how."	^self accept%category: ''services-status''method: SpSocketbindSocketAddress: aSocketAddress 	"^self	Equivalent of:  bind(int  sockfd, struct sockaddr *my_addr, socklen_t addrlen);	see man bind.	Bind the socket to aSocketAddress."	self underlyingSocket bindTo: aSocketAddress portNumber toAddress: aSocketAddress hostAddressString.	^self%category: ''services-status''method: SpSocketclose	"^self	The same as the close() posix function."	self underlyingSocket close.	^self%category: ''services-status''method: SpSocketconnectTo: aSocketAddress 	"^self	I instruct my underlying socket to connect to aSocketAddress."	self underlyingSocket connectTo: aSocketAddress portNumber on: aSocketAddress hostAddressString.	^self%category: ''services-status''method: SpSocketlistenBackloggingUpTo: aNumberOfConnections 	"^self	I set the socket I represent listening for incomming connections, allowing a 	backlog of up to aNumberOfConnections."	self underlyingSocket makeListener: aNumberOfConnections.	^self%category: ''services-status''method: SpSocketsetOptionForLevel: aLevelNumber optionID: anOptionNumber value: aValue 	"^self	see man 2 setsockopt	From the manpage:	Getsockopt  and  setsockopt  manipulate  the  options associated with a       socket.  Options may exist at multiple protocol levels; they are always       present at the uppermost socket level."	1 halt: ''Doh!  - can''''t do this in GemStone yet.''.	self underlyingSocket 		setOptionsLevel: aLevelNumber		name: anOptionNumber		value: aValue.	^self%category: ''services-streams''method: SpSocketreadStream	"^nilWhile this is convinient, it would mean that sockets would depend on streams, and we want to avoid that.Use {my stream class} on: {my socket} instead."	^self shouldNotImplement%category: ''services-streams''method: SpSocketwriteStream	"^nilWhile this is convinient, it would mean that sockets would depend on streams, and we want to avoid that.Use {my stream class} on: {my socket} instead."	^self shouldNotImplement%category: ''testing''method: SpSocketisActive	^self underlyingSocket isActive%! Remove existing behavior from SpSocketAddressdoitSpSocketAddress removeAllMethods.SpSocketAddress class removeAllMethods.%! ------------------- Class methods for SpSocketAddresscategory: ''instance creation''classmethod: SpSocketAddresson: subjectAddress for: aSocket 	"^an SpSocketAddress	Well, in the future there may be more than one kind of socket address,	but for now there is just SpIPAddress, so I return one of those on the 	details embodied in the subjectAddress. 	No use is made of aSocket as yet, but it will be useful when there	are more kinds of socket address supported."	^SpIPAddress host: subjectAddress hostAddress port: subjectAddress port%! ------------------- Instance methods for SpSocketAddress! Remove existing behavior from SpIPAddressdoitSpIPAddress removeAllMethods.SpIPAddress class removeAllMethods.%! ------------------- Class methods for SpIPAddresscategory: ''instanceCreation''classmethod: SpIPAddresshost: aHostAddress port: aPortNumber 	"^an SpSocketAddress	I create a new instance of myself which represents an IP address/port combination	(a TCP/IP address, really).  Note that aHostAddress must be a four element byte 	array (e.g. #[127 0 0 1]) ."	^self new host: aHostAddress port: aPortNumber%category: ''services''classmethod: SpIPAddresshostName: aHostNameString port: aPortNumber 	"^an SpSocketAddress	I translate aHostNameString to an IP address and then create	a new instance of myself with &gt;&gt;host:port:"	^self host: (GsSocket getHostAddressByName: aHostNameString)		port: aPortNumber%! ------------------- Instance methods for SpIPAddresscategory: ''accessing''method: SpIPAddresshostAddress	^hostAddress%category: ''accessing''method: SpIPAddressportNumber	^portNumber%category: ''initialize-release''method: SpIPAddresshost: aHostAddress port: aPortNumber 	hostAddress := aHostAddress.	portNumber := aPortNumber.	^self%category: ''printing''method: SpIPAddresshostAddressString	^hostAddress%'</body></methods><methods><class-id>SpSocketsCodeForSqueak class</class-id> <category>code strings</category><body package="SpSockets">codeString	"^a String	I return the string which is the source code for the OpenSkills GemStone sockets classes."	"(Filename named: 'SpSockets-squeak.st') writeStream nextPutAll: self codeString; close"	^'Object subclass: #SpSocket	instanceVariableNames: ''underlyingSocket socketAddress''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpSockets''!!SpSocket methodsFor: ''initialize-release'' stamp: ''BB 1/22/2006 17:00''!onUnderlyingSocket: aSocket 	underlyingSocket := aSocket.	^self! !!SpSocket methodsFor: ''private'' stamp: ''BB 1/25/2006 21:48''!onNativeclientSocket: aNativeSocket for: aServerSocket 	"^self	I initialize myself with the same properties as aServerSocket and with	aNativeSocket as my underlying socket.""	communicationDomain := aServerSocket communicationDomain.	socketType := aServerSocket socketType.	protocolNumber := aServerSocket protocolNumber."	underlyingSocket := aNativeSocket.	^self! !!SpSocket methodsFor: ''private'' stamp: ''BB 1/22/2006 18:44''!underlyingSocket	^underlyingSocket! !!SpSocket methodsFor: ''services-accessing'' stamp: ''BB 1/31/2006 21:50''!getPeerName	"^an OSkSocketAddress	see man getpeername.	I return the socket address of the other/remote/peer end of the socket I	represent."	^ SpIPAddress host: self underlyingSocket remoteAddress port: self underlyingSocket remotePort! !!SpSocket methodsFor: ''services-accessing'' stamp: ''BB 1/31/2006 21:56''!getSocketName	"^an OSkSocketAddress	see: man getsockname	I return my local socket address which may be any subclass of 	OSkSocketAddress."	^ SpIPAddress host: self underlyingSocket localAddress port: self underlyingSocket localPort! !!SpSocket methodsFor: ''services-status'' stamp: ''BB 1/31/2006 16:50''!accept	"^an OSkSocket	I accept the next connection made to the server socket I represent.	This is a *blocking* request. That is, this method will not exit until	an inbound socket connection is made. When that happens the new	socket connected to the client (not the server socket) will be returned."	^ SpExceptionContext		for: [| clientSpecificSocket | 			[(clientSpecificSocket := self underlyingSocket						waitForAcceptFor: 1						ifTimedOut: [nil]) isNil] whileTrue.			self class onNativeclientSocket: clientSpecificSocket for: self]		on: Error		do: [:ex | SpSocketError new parameter: ex;				 raiseSignal: ''Error while trying to accept a socket connection.'']! !!SpSocket methodsFor: ''services-status'' stamp: ''BB 1/25/2006 21:26''!acceptRetryingIfTransientErrors		"^an OSkSocket	I try to do an accept.  If I get an exception which is ''transient'' I retry.	For now in Squeak, I just do the accept"	"^SpExceptionContext 		for: [self accept]		on: OSErrorHolder transientErrorSignal		do: [:ex | ex restart]"	^self accept! !!SpSocket methodsFor: ''services-status'' stamp: ''BB 1/25/2006 16:40''!bindSocketAddress: aSocketAddress 	"^self	Equivalent of: bind(int sockfd, struct sockaddr *my_addr, socklen_t	addrlen); see man bind. Bind the socket to aSocketAddress.	It seems that Squeak merges the ''bind'' and the ''listen'', so here I''ll just	remember the socket address and use it when I get the listen request."	socketAddress := aSocketAddress.	^self! !!SpSocket methodsFor: ''services-status'' stamp: ''BB 1/23/2006 11:09''!close	"^self	The same as the close() posix function."	self underlyingSocket close! !!SpSocket methodsFor: ''services-status'' stamp: ''BB 1/22/2006 18:47''!connectTo: aSocketAddress 	"^self	I instruct my underlying socket to connect to aSocketAddress."	self underlyingSocket connectTo: aSocketAddress hostAddress port: aSocketAddress portNumber! !!SpSocket methodsFor: ''services-status'' stamp: ''BB 1/25/2006 20:57''!listenBackloggingUpTo: aNumberOfConnections 	"^self	I set the socket I represent listening for incomming connections,	allowing a 	backlog of up to aNumberOfConnections.	Note that Squeak combines bind and listen so I noted the socket address	when I was asked to bind - and I use that now.	OK - I really wanter to be able to specify the interface, but that seems 	to be broken - I get a primative error when I try to use it"	self underlyingSocket		listenOn: socketAddress portNumber		backlogSize: aNumberOfConnections"		interface: socketAddress hostAddress". 	^self! !!SpSocket methodsFor: ''testing'' stamp: ''BB 1/25/2006 21:21''!isActive	"^a Boolean	There is no simple &gt;&gt;isActive test, it seems."	^ self underlyingSocket isConnected		or: [self underlyingSocket isWaitingForConnection]! !!SpSocket methodsFor: ''services-io'' stamp: ''BB 1/23/2006 11:08''!readInto: aByteArray startingAt: startIndex for: aNumberOfBytes 	"^an Integer	I return the number of bytes actually read.	In Squeak it seems we can not specify the number of bytes to be read.	We get what its there no matter how much their is!!"	| actuallyRead |	actuallyRead := self underlyingSocket receiveDataInto: aByteArray startingAt: startIndex.	actuallyRead &gt; aNumberOfBytes		ifTrue: [1 halt].	^ actuallyRead! !!SpSocket methodsFor: ''services-io'' stamp: ''BB 1/23/2006 09:10''!readyForRead	"^a BooleanI return true if a read operation will return some number of bytes."	^self underlyingSocket dataAvailable! !!SpSocket methodsFor: ''services-io'' stamp: ''BB 1/31/2006 17:18''!read: targetNumberOfBytes 	"^a ByteArray	I attempt to read the targetNumberOfBytes from my underlying socket.	If the targetNumberOfBytes	are not available, I return what I can get."	| targetByteArray numberOfBytesActuallyRead |	^ SpExceptionContext		for: [targetByteArray := ByteArray new: targetNumberOfBytes.			numberOfBytesActuallyRead := self underlyingSocket receiveDataInto: targetByteArray.			targetByteArray copyFrom: 1 to: numberOfBytesActuallyRead]		on: Error		do: [:ex | SpSocketError raiseSignal: ex]! !!SpSocket methodsFor: ''services-io'' stamp: ''BB 1/23/2006 09:57''!waitForReadDataUpToMs: aNumberOfMilliseconds 	"^a Boolean	I return true if we think data became available within	aNumberOfMilliseconds, and false if we timed out.	Squeak wants a timeout in seconds, so I convert it here."	| aNumberOfSeconds |	aNumberOfSeconds := (aNumberOfMilliseconds / 1000) ceiling.	self underlyingSocket		waitForDataFor: aNumberOfSeconds		ifClosed: [SpError signal: ''Socket closed while waiting for data''.			^ false]		ifTimedOut: [^ false].	^ true! !!SpSocket methodsFor: ''services-io'' stamp: ''BB 1/23/2006 08:56''!writeFrom: aByteArray startingAt: startIndex for: length 	"^an Integer	I return the number of bytes actually written."	^ self underlyingSocket		sendSomeData: aByteArray		startIndex: startIndex		count: length! !!SpSocket methodsFor: ''services-io'' stamp: ''BB 1/31/2006 22:56''!write: sourceByteArray 	"^an Integer	I write the contents of the sourceByteArray to my underlying Socket.	I return the number of bytes written."	^ SpExceptionContext		for: [self underlyingSocket sendSomeData: sourceByteArray]		on: Error		do: [:ex | SpSocketError raiseSignal: ex]! !!SpSocket methodsFor: ''services-options'' stamp: ''BB 1/25/2006 19:58''!setAddressReuse: aBoolean 	"^self	c.f. self class &gt;&gt;socketOptions and self &gt;&gt;setOptionForLevel:optionID:value:	If a boolean is true, I set address reuse on, otherwise I set address reuse	off. "	"self underlyingSocket setOption: ''SO_REUSEADDR'' value: aBoolean"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SpSocket class	instanceVariableNames: ''''!!SpSocket class methodsFor: ''private'' stamp: ''BB 1/25/2006 21:34''!onNativeclientSocket: aNativeSocket for: aServerSocket 	"^an OSkSocketI create a new instance of my self at the request of aServerSocket  wherethis new instance will be a connected client socket (connected via aNativeSoket)."	^self new onNativeclientSocket: aNativeSocket for: aServerSocket! !!SpSocket class methodsFor: ''instance creation'' stamp: ''BB 1/22/2006 18:41''!connectToServerOnHost: hostName port: portNumber 	"^an OSkSocket 	I return a new instance of myself which represents a socket connecter	to a server listening on portNumber at hostName."	| newSocket |	newSocket := self newTCPSocket.	newSocket		connectTo: (SpIPAddress hostName: hostName port: portNumber).	^ newSocket! !!SpSocket class methodsFor: ''instance creation'' stamp: ''BB 1/30/2006 22:48''!newTCPSocket	"^an OSkSocket	I return a new instance of myself that represents an unconfigured TCP	socket."	Socket initializeNetwork.	^ self new onUnderlyingSocket: Socket newTCP! !Object subclass: #SpSocketAddress	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpSockets''!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SpSocketAddress class	instanceVariableNames: ''''!!SpSocketAddress class methodsFor: ''instance creation'' stamp: ''BB 1/31/2006 21:41''!on: subjectAddress for: aSocket 	"^an OSkSocketAddress	Well, in the future there may be more than one kind of socket address,	but for now there is just OSkIPAddress, so I return one of those on the 	details embodied in the subjectAddress. 	No use is made of aSocket as yet, but it will be useful when there	are more kinds of socket address supported."	^SpIPAddress host: subjectAddress hostAddress port: subjectAddress port! !SpSocketAddress subclass: #SpIPAddress	instanceVariableNames: ''hostAddress portNumber''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpSockets''!!SpIPAddress methodsFor: ''printing'' stamp: ''BB 1/31/2006 21:51''!hostAddressString	| targetStream |	targetStream := String new writeStream.	targetStream		nextPutAll: (self hostAddress at: 1) printString;		nextPut: $.;		nextPutAll: (self hostAddress at: 2) printString;		nextPut: $.;		nextPutAll: (self hostAddress at: 3) printString;		nextPut: $.;		nextPutAll: (self hostAddress at: 4) printString.	^targetStream contents! !!SpIPAddress methodsFor: ''initialize-release'' stamp: ''BB 1/22/2006 17:55''!host: aHostAddress port: aPortNumber 	hostAddress := aHostAddress.	portNumber := aPortNumber! !!SpIPAddress methodsFor: ''accessing'' stamp: ''BB 1/22/2006 18:47''!hostAddress	^ hostAddress! !!SpIPAddress methodsFor: ''accessing'' stamp: ''BB 1/22/2006 18:47''!portNumber	^ portNumber! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SpIPAddress class	instanceVariableNames: ''''!!SpIPAddress class methodsFor: ''instance creation'' stamp: ''BB 1/22/2006 17:56''!connectToServerOnHost: hostName port: portNumber 	"^an OSkSocket 	I return a new instance of myself which represents a socket connecter	to a server listening on portNumber at hostName."	| newSocket |	newSocket := self newTCPSocket.	newSocket		connectTo: (SpIPAddress hostName: hostName port: portNumber).	^ newSocket! !!SpIPAddress class methodsFor: ''instance creation'' stamp: ''BB 1/22/2006 17:54''!hostName: aHostNameString port: aPortNumber 	"^an OSkSocketAddress	I translate aHostNameString to an IP address and then create	a new instance of myself with &gt;&gt;host:port:"	^ self		host: (NetNameResolver addressForName: aHostNameString)		port: aPortNumber! !!SpIPAddress class methodsFor: ''instance creation'' stamp: ''BB 1/22/2006 17:51''!host: aHostAddress port: aPortNumber 	"^an OSkSocketAddress	I create a new instance of myself which represents an IP address/port	combination (a TCP/IP address, really). Note that aHostAddress must be a	four element byte 	array (e.g. #[127 0 0 1]) ."	^ self new host: aHostAddress port: aPortNumber! !SpError subclass: #SpSocketError	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpSockets''!'</body></methods><methods><class-id>SpFilesCodeForGemStone class</class-id> <category>code strings</category><body package="SpFiles">codeString	"^a String	I return the string which is the source code for the GemStone compatibility classes."	"(Filename named: 'SpFiles.gs') writeStream nextPutAll: self codeString; close"	^'!! From ! GEMSTONE: 6.1, Thu Apr 17 20:11:38 US/Pacific 2003; IMAGE: GemStone v6.1 kernel classes filein completed at 17/04/2003 20:22:36! GemStone v6.1 kernel classes filein of stripped sources completed at 17/04/2003 20:31:50! ! On December 24, 2008, 3:44:28 pm!!! SymbolDictionary ''SpFiles''!run| symList newDict |symList := System myUserProfile symbolList.symList do: [ :element |    (element includesKey: #SpFiles)        ifTrue: [ ^element ]].newDict := SymbolDictionary new.newDict at: #SpFiles put: newDict.System myUserProfile insertDictionary: newDict at: 1.^newDict%doit(Object subclass: ''SpFilename''  instVarNames: #( filenameString)  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpFiles  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''SpFileStream''  instVarNames: #( underlyingStream filename)  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpFiles  constraints: #[]  instancesInvariant: false  isModifiable: true).%doitSpFilename immediateInvariant.%doitSpFileStream immediateInvariant.%! Remove existing behavior from SpFilenamedoitSpFilename removeAllMethods.SpFilename class removeAllMethods.%! ------------------- Class methods for SpFilenamecategory: ''instance creation''classmethod: SpFilenamenamed: aString 	"^an SpFilenameI create a new instance of myself to represent the filename identified by aString."	^self new named: aString%! ------------------- Instance methods for SpFilenamecategory: ''initialize-release''method: SpFilenamenamed: aFilenameString         "^selfI initialize myself to represent the filename identified by aString."        filenameString := aFilenameString.        ^self %category: ''private''method: SpFilenamefilenameString        ^filenameString%category: ''services''method: SpFilenameappendStream	"^an SpFileStreamI create an append stream on the file I represent."	^SpFileStream appendingToFilename: self%category: ''services''method: SpFilenameasString	^self filenameString%category: ''services''method: SpFilenamedelete	GsFile removeClientFile: self filenameString.	^self%category: ''services''method: SpFilenamereadStream	"^an SpFileStreamI create a read stream on the file I represent."	^SpFileStream readingFromFilename: self%category: ''services''method: SpFilenamewriteStream	"^an SpFileStreamI create a write stream on the file I represent."	^SpFileStream writingToFilename: self%category: ''testing''method: SpFilenameexists	"^a BoolianI return true if the file I represent actually exists, otherwise false."	^GsFile exists: self filenameString%! Remove existing behavior from SpFileStreamdoitSpFileStream removeAllMethods.SpFileStream class removeAllMethods.%! ------------------- Class methods for SpFileStreamcategory: ''instance creation''classmethod: SpFileStreamappendingToFilename: anSpFilename 	"^an SpFileStreamI create a new instance of myself to append to the file identified by anSpFilename."	^self new appendingToFilename: anSpFilename%category: ''instance creation''classmethod: SpFileStreamreadingFromFilename: anSpFilename 	"^an SpFileStreamI create a new instance of myself to read the file identified by anSpFilename."	^self new readingFromFilename: anSpFilename%category: ''instance creation''classmethod: SpFileStreamreadingFromFileNamed: aString 	"^an SpFileStreamI create a new instance of myself to read from a file named aString."	^self new readingFromFileNamed: aString%category: ''instance creation''classmethod: SpFileStreamwritingToFilename: anSpFilename 	"^an SpFileStreamI create a new instance of myself to append to the file identified by anSpFilename."	^self new writingToFilename: anSpFilename%category: ''instance creation''classmethod: SpFileStreamwritingToFileNamed: aString 	"^an SpFileStreamI create a new instance of myself to write to a file named aString."	^self new writingToFileNamed: aString%! ------------------- Instance methods for SpFileStreamcategory: ''accessing''method: SpFileStreamcontentsStream	^self underlyingStream contents readStream%category: ''accessing''method: SpFileStreamfilename	^filename%category: ''accessing''method: SpFileStreamfilename: anObject	filename := anObject%category: ''accessing''method: SpFileStreamunderlyingStream	^underlyingStream%category: ''initialize-release''method: SpFileStreamappendingToFilename: anSpFilename 	filename := anSpFilename asString.	underlyingStream := GsFile openAppend: anSpFilename filenameString.	^self%category: ''initialize-release''method: SpFileStreamreadingFromFilename: anSpFilename 	filename := anSpFilename asString.	underlyingStream := GsFile openRead: anSpFilename filenameString.	^self%category: ''initialize-release''method: SpFileStreamreadingFromFileNamed: aString 	"^selfI initialize myself to read from a file named aString."	filename := aString.	underlyingStream := GsFile openRead: aString.	^self%category: ''initialize-release''method: SpFileStreamwritingToFilename: anSpFilename 	filename := anSpFilename asString.	underlyingStream := GsFile openWrite: anSpFilename filenameString.	^self%category: ''initialize-release''method: SpFileStreamwritingToFileNamed: aString 	"^selfI initialize myself to write to a file named aString."	filename := aString.	underlyingStream := GsFile openWrite: aString.	^self%category: ''services''method: SpFileStreamatEnd	^self underlyingStream atEnd%category: ''services''method: SpFileStreamclose	^self underlyingStream close%category: ''services''method: SpFileStreamclosed	^self underlyingStream isOpen not%category: ''services''method: SpFileStreamcontents	^self underlyingStream contents%category: ''services''method: SpFileStreamcr	^self underlyingStream cr%category: ''services''method: SpFileStreamflush	^self underlyingStream flush%category: ''services''method: SpFileStreamnext	^self underlyingStream next%category: ''services''method: SpFileStreamnextPut: anObject	^self underlyingStream nextPut: anObject%category: ''services''method: SpFileStreamnextPutAll: aCollection 	^self underlyingStream nextPutAll: aCollection%category: ''services''method: SpFileStreampeek	^self underlyingStream peek%category: ''services''method: SpFileStreamposition	^self underlyingStream position%category: ''services''method: SpFileStreamposition: aNumber	^self underlyingStream position: aNumber%category: ''services''method: SpFileStreamskip: anInteger	^self underlyingStream skip: anInteger%category: ''services''method: SpFileStreamthroughAll: aCollection	^self underlyingStream throughAll: aCollection%category: ''services''method: SpFileStreamupTo: anObject 	"^a CollectionI return the content of my underlying file up to anObject or the end of the file, excluding anObject.  The stream (file) is left positioned *after* anObject."	| targetStream |	targetStream := WriteStream on: String new.	[self underlyingStream atEnd or: [self underlyingStream peek == anObject]] 		whileFalse: [targetStream nextPut: self underlyingStream next].	self underlyingStream atEnd ifFalse: [self underlyingStream next].	^targetStream contents%category: ''services''method: SpFileStreamupToAll: aCollection	^self underlyingStream upToAll: aCollection%category: ''services''method: SpFileStreamupToEnd	^self underlyingStream contents%'</body></methods><methods><class-id>SpSocket</class-id> <category>services-status</category><body package="SpSockets">accept	"^an OSkSocket	I accept the next connection made to the server socket I represent.  I return a new	instance of OSkSocket which represents the socket over which information can be	exchanged.	NOTE: this call will block waiting for an inbound connection"	^SpExceptionContext 		for: [self class onNativeclientSocket: self underlyingSocket accept for: self]		on: Error		do: [:ex | SpSocketError signalWith: ex]</body><body package="SpSockets">acceptRetryingIfTransientErrors	"^an OSkSocket	I try to do an accept.  If I get an exception which is 'transient' I retry."	^SpExceptionContext 		for: [self accept]		on: OSErrorHolder transientErrorSignal		do: [:ex | ex restart]</body><body package="SpSockets">bindSocketAddress: aSocketAddress 	"^self	Equivalent of:  bind(int  sockfd, struct sockaddr *my_addr, socklen_t addrlen);	see man bind.	Bind the socket to aSocketAddress."	self underlyingSocket bindTo: (aSocketAddress asNativeSocketAddress).	^self</body><body package="SpSockets">close	"^self	The same as the close() posix function."	self underlyingSocket close.	^self</body><body package="SpSockets">connectTo: aSocketAddress 	"^self	I instruct my underlying socket to connect to aSocketAddress."	self underlyingSocket connectTo: aSocketAddress asNativeSocketAddress.	^self</body><body package="SpSockets">connectTo: aSocketAddress timeout: aNumberOfMilliseconds 	"^self	I instruct my underlying socket to connect to aSocketAddress."	self underlyingSocket connectTo: aSocketAddress asNativeSocketAddress		timeout: aNumberOfMilliseconds.	^self</body><body package="SpSockets">listenBackloggingUpTo: aNumberOfConnections 	"^self	I set the socket I represent listening for incomming connections, allowing a 	backlog of up to aNumberOfConnections."	self underlyingSocket listenFor: aNumberOfConnections.	^self</body><body package="SpSockets">setOptionForLevel: aLevelNumber optionID: anOptionNumber value: aValue 	"^self	see man 2 setsockopt	From the manpage:	Getsockopt  and  setsockopt  manipulate  the  options associated with a       socket.  Options may exist at multiple protocol levels; they are always       present at the uppermost socket level."	self underlyingSocket 		setOptionsLevel: aLevelNumber		name: anOptionNumber		value: aValue.	^self</body></methods><methods><class-id>SpSocket</class-id> <category>services-streams</category><body package="SpSockets">readStream	"^nilWhile this is convinient, it would mean that sockets would depend on streams, and we want to avoid that.Use {my stream class} on: {my socket} instead."	^self shouldNotImplement</body><body package="SpSockets">writeStream	"^nilWhile this is convinient, it would mean that sockets would depend on streams, and we want to avoid that.Use {my stream class} on: {my socket} instead."	^self shouldNotImplement</body></methods><methods><class-id>SpSocket</class-id> <category>private</category><body package="SpSockets">onNativeclientSocket: aNativeSocket for: aServerSocket 	"^self	I initialize myself with the same properties as aServerSocket and with	aNativeSocket as my underlying socket."	communicationDomain := aServerSocket communicationDomain.	socketType := aServerSocket socketType.	protocolNumber := aServerSocket protocolNumber.	underlyingSocket := aNativeSocket.	^self</body><body package="SpSockets">underlyingSocket	^underlyingSocket</body></methods><methods><class-id>SpSocket</class-id> <category>services-accessing</category><body package="SpSockets">getPeerName	"^an OSkSocketAddress	see man getpeername.	I return the socket address of the other/remote/peer end of the socket I represent."	^SpSocketAddress on: self underlyingSocket getPeer for: self</body><body package="SpSockets">getSocketName	"^an OSkSocketAddress	see: man getsockname	I return my local socket address which may be any subclass of 	OSkSocketAddress."	^SpSocketAddress on: self underlyingSocket getName for: self</body></methods><methods><class-id>SpSocket</class-id> <category>testing</category><body package="SpSockets">isActive	^self underlyingSocket isActive</body></methods><methods><class-id>SpSocket</class-id> <category>services-io</category><body package="SpSockets">read: targetNumberOfBytes 	"^a ByteArray	I attempt to read the targetNumberOfBytes from my underlying socket.  If the targetNumberOfBytes	are not available, I return what I can get."	^	[activeReadRequest := SpBlockingSocketReadRequest for: self.	activeReadRequest read: targetNumberOfBytes] 			ensure: [activeReadRequest := nil]</body><body package="SpSockets">readInto: aByteArray startingAt: startIndex for: aNumberOfBytes 	"^an IntegerI return the number of bytes actually read.  This call will block waiting for activity on the socket.  If the number of octets read is zero, this means that the peer has performed an orderly shutdown of the socket and in this case I raise an exception.  c.f. the man page for recv()"	^	[activeReadRequest := SpBlockingSocketReadRequest for: self.	activeReadRequest 		recvInto: aByteArray		startingAt: startIndex		for: aNumberOfBytes] 			ensure: [activeReadRequest := nil]</body><body package="SpSockets">readyForRead	"^a BooleanI return true if a read operation will return some number of bytes."	^	[activeReadRequest := SpBlockingSocketReadRequest for: self.	activeReadRequest readyForRead] 			ensure: [activeReadRequest := nil]</body><body package="SpSockets">waitForReadDataUpToMs: aNumberOfMilliseconds 	"^a Boolean	I return true if we think data became available within aNumberOfMilliseconds, and	false if we timed out.	Martin Kobetic on the vwnc list said that getting a successful read wait but finding	no bytes available to read means that the remote end closed the socket - so in this	case I now raise an exception."	^	[activeReadRequest := SpBlockingSocketReadRequest for: self.	activeReadRequest waitForReadDataUpToMs: aNumberOfMilliseconds] 			ensure: [activeReadRequest := nil]</body><body package="SpSockets">write: sourceByteArray 	"^an Integer	I write the contents of the sourceByteArray to my underlying Socket.	I return the number of bytes written."	^SpExceptionContext 		for: [self underlyingSocket writeFrom: sourceByteArray]		on: Error		do: [:ex | SpSocketError signalWith: ex]</body><body package="SpSockets">writeFrom: aByteArray startingAt: startIndex for: length 	"^an IntegerI return the number of bytes actually written."	^self underlyingSocket 		writeFrom: aByteArray		startingAt: startIndex		for: length</body></methods><methods><class-id>SpSocket</class-id> <category>initialize-release</category><body package="SpSockets">onNativeSocket: aSocket forDomain: aCommunicationDomain type: aSocketType protocol: aProtocolNumber 	"^self	I initialize myself as a socket defined by the communications domain, type and protocol.  This	follows the equivalent of the using the socket()  or socketpair() function."	communicationDomain := aCommunicationDomain.	socketType := aSocketType.	protocolNumber := aProtocolNumber.	underlyingSocket := aSocket.	^self</body></methods><methods><class-id>SpSocket</class-id> <category>accessing</category><body package="SpSockets">communicationDomain	^communicationDomain</body><body package="SpSockets">protocolNumber	^protocolNumber</body><body package="SpSockets">socketType	^socketType</body></methods><methods><class-id>SpSocket</class-id> <category>services-options</category><body package="SpSockets">setAddressReuse: aBoolean 	"^self	c.f. self class &gt;&gt;socketOptions and self &gt;&gt;setOptionForLevel:optionID:value:	If a boolean is true, I set address reuse on, otherwise I set address reuse off."	| optionValue |	optionValue := aBoolean ifTrue: [1] ifFalse: [0].	self 		setOptionForLevel: (self class socketOptionLevels at: #SOL_SOCKET)		optionID: (self class socketOptions at: #SO_REUSEADDR)		value: optionValue.	^self</body></methods><methods><class-id>SpSocket</class-id> <category>stalled time</category><body package="SpSockets">incrementSumOfStalledTimeBy: aNumberOfMilliseconds 	sumOfStalledTime := self sumOfStalledTime + aNumberOfMilliseconds.	^self</body><body package="SpSockets">resetSumOfStalledTime	sumOfStalledTime := 0.	^self</body><body package="SpSockets">stalledTimeCeiling	"^an IntegerI return the integer number of seconds for which a socket can be 'stalled' (i.e. returning before the timeout on a read wait but having zero bytes actually available) before an exception is raised.  The default is 600,000 milliseconds (10 minutes) "	stalledTimeCeiling isNil ifTrue: [stalledTimeCeiling := 600000].	^stalledTimeCeiling</body><body package="SpSockets">stalledTimeCeiling: aNumberOfMilliseconds 	"^selfI record the integer number of seconds for which a socket can be 'stalled'.  c.f.  &gt;&gt;stalledTimeCeiling "	stalledTimeCeiling := aNumberOfMilliseconds.	^self</body><body package="SpSockets">sumOfStalledTime	sumOfStalledTime isNil ifTrue: [self resetSumOfStalledTime].	^sumOfStalledTime</body></methods><methods><class-id>SpSocket</class-id> <category>services-io non-blocking</category><body package="SpSockets">activeReadRequest	^activeReadRequest</body><body package="SpSockets">recvWithoutBlockingInto: aByteArray startingAt: startIndex for: aNumberOfOctets 	"^an IntegerThis implements recv() per http://linux.die.net/man/2/recv as closely a possible.  i.e. recv(int s, void *buf, size_t len, int flags) except for flags.  s is me (self), a connected socket.  *buf and len are a combination of aByteArray, startIndex and aNumberOfOctets (since *buf may point to the current start point in a larger buffer).Sockets in VisualWorks are non-blocking (i.e.  O_NONBLOCK is set) so socket reads do not block the VM ... BUT, the read interface to a socket in Smalltalk (via SocketAccessor) *is* blocking.  c.f. SocketAccessor&gt;&gt;privateReadInto:startingAt:for:So, in order to get a non-blocking effect, I need to create a Smalltalk process that blocks on the SocketAccessors read activity which I can monitor without blocking the Smalltalk process that called me.The buffer (aByteArray) must be used as follows:  Once a request has been made to read into aByteArray the actual buffer update might happen at any time, so don't mess with the buffer until this method has returned a positive integer indicating that some octets have been read.  You can keep calling this method and get a zero response, but you must keep calling with the same object for aByteArray (or you'll get an exception).The responses from this method will always be an integer or an exception (The exception takes the place of a negative return value from recv() in the land of C).  The integer is the number of octets read.  A return of 0 indicates that a forked read process is still hard at work waiting for SocketAccessor to read octets from the real underlying socket."	^	[activeReadRequest := SpNonBlockingSocketReadRequest for: self.	activeReadRequest 		recvInto: aByteArray		startingAt: startIndex		for: aNumberOfOctets] 			ensure: [activeReadRequest isComplete ifTrue: [activeReadRequest := nil]]</body><body package="SpSockets">waitForNonBlockingReadActivityUpToMs: aNumberOfMilliseconds 	"^a BooleanI return true if there has been some read related activity on my underlying socket, otherwise false.  Note that activity may not mean that data is available.  It may just mean that the socket is in a new (perhaps error) state."	^	[activeReadRequest := SpNonBlockingSocketReadRequest for: self.	activeReadRequest 		waitForNonBlockingReadActivityUpToMs: aNumberOfMilliseconds] 			ensure: [activeReadRequest := nil]</body></methods><methods><class-id>SpSocket class</class-id> <category>private</category><body package="SpSockets">onNativeclientSocket: aNativeSocket for: aServerSocket 	"^an OSkSocketI create a new instance of my self at the request of aServerSocket  wherethis new instance will be a connected client socket (connected via aNativeSoket)."	^self new onNativeclientSocket: aNativeSocket for: aServerSocket</body><body package="SpSockets">resetAllDefinedValues	"^self	I simply set the all the symbol dictionaries containing defined values to	nil, forcing them to be re-initialized on demand."	"SpSocket resetAllDefinedValues."	addressFamilies := nil.	protocolFamilies := nil.	socketTypes := nil.	fileControlOptions := nil.	socketOptions := nil.	socketOptionLevels := nil.	^self</body></methods><methods><class-id>SpSocket class</class-id> <category>services</category><body package="SpSockets">getHostname	"^a StringI return the name of the host computer, i.e. the machine this code is running on."	^SocketAccessor getHostname</body><body package="SpSockets">initialize	^self resetAllDefinedValues</body><body package="SpSockets">newSocketPair	"^an Array	I return an array containing two OSkSockets each representing one end of a	#PF_UNIX connection."	^self socketPairForDomain: #PF_UNIX type: #SOCK_STREAM</body></methods><methods><class-id>SpSocket class</class-id> <category>defined symbols</category><body package="SpSockets">addressFamilies	"^an IdentityDictionaryI return the dictionary mapping each defined address family symbol to it's numericvalue.  See socket.h and look for the #def AF_xxx lines.Since the hard work on the various codes has been done by the nice people at Cincom, I just delegate to Socket Accessor for the actual values here in VisualWorks.If you modify this method, evaluate the following:		'SpSocket resetAllDefinedValues' "	addressFamilies isNil 		ifTrue: 			[addressFamilies := (IdentityDictionary new)						at: #AF_UNIX put: SocketAccessor AF_UNIX;						at: #AF_LOCAL put: SocketAccessor AF_LOCAL;						at: #AF_INET put: SocketAccessor AF_INET;						yourself].	^addressFamilies</body><body package="SpSockets">fileControlOptions	"^an IdentityDictionary	I return the dictionary mapping each defined file control symbol to it's numeric	value.  See fcntl.h and look for the at: #O_xxx lines.	Really this is here for the O_NONBLOCK option which sets the fd (file descriptor)	of a socket to non-blocking mode when used in an fcntl() function.	If you modify this method, evaluate the following:		'SpSocket resetAllDefinedValues' "	fileControlOptions isNil 		ifTrue: 			[fileControlOptions := (IdentityDictionary new)						at: #O_ACCMODE put: 0003;						at: #O_RDONLY put: 00;						at: #O_WRONLY put: 01;						at: #O_RDWR put: 02;						at: #O_CREAT put: 0100;						at: #O_EXCL put: 0200;						at: #O_NOCTTY put: 0400;						at: #O_TRUNC put: 01000;						at: #O_APPEND put: 02000;						at: #O_NONBLOCK put: 04000;						at: #O_NDELAY put: 04000;						at: #O_SYNC put: 010000;						at: #FASYNC put: 020000;						at: #O_DIRECT put: 040000;						at: #O_LARGEFILE put: 0100000;						at: #O_DIRECTORY put: 0200000;						at: #O_NOFOLLOW put: 0400000;						yourself].	^fileControlOptions</body><body package="SpSockets">protocolFamilies	"^an IdentityDictionary	I return the dictionary mapping each defined protocol family symbol to it's numeric	value.  See socket.h and look for the #def PF_xxx lines.	Since the hard work on the various codes has been done by the nice people at Cincom, I just delegate to Socket Accessor for the actual values here in VisualWorks.	If you modify this method, evaluate the following:		'SpSocket resetAllDefinedValues' "	protocolFamilies isNil 		ifTrue: 			[protocolFamilies := (IdentityDictionary new)						at: #PF_UNIX put: SocketAccessor PF_UNIX;						at: #PF_LOCAL put: SocketAccessor PF_LOCAL;						at: #PF_INET put: SocketAccessor PF_INET;						yourself].	^protocolFamilies</body><body package="SpSockets">socketConstantsPerPlatformCSVString	"^a StringThis is a spreadsheet in string format which was produced by Tom Robinson.  He says: 'I looked at constant definitions on the various platform subclasses of SocketAccessor and created a spreadsheet of values for some of the options I found.  I haven't verified that ALL of them are correct, but they are what is currently defined in VisualWorks as of build may09.5.'It can be handy to look at this information in a spreadsheet, so I include it here.  Please post to cls or similar if you see something wrong here.  Thanks."	^'"  O","Linux value","Windows value","MacOSX value","Solaris value","AIX value","HPUX value","OpenBSD value","Comments",,,,,,,,"Address families",,,,,,,,"AF_INET",2,2,2,2,2,2,2,"AF_UNIX",1,1,1,1,1,1,1,,,,,,,,,"Socket types",,,,,,,,"SOCK_STREAM",1,1,1,2,1,1,1,"SOCK_DGRAM",2,2,2,1,2,2,2,"SOCK_RAW",3,3,3,4,3,3,3,"SOCK_RDM",4,4,4,5,4,4,4,"Reliable datagrams - not supported on most systems""SOCK_SEQPACKET",5,5,5,6,5,5,5,,,,,,,,,"Socket options",,,,,,,,"SO_DEBUG",1,1,1,,1,,,"turn on debug infor recording""SO_REUSEADDR",2,4,4,4,4,4,4,"allow local address reuse""SO_TYPE",3,4104,4104,,4104,,,"get socket type""SO_ERROR",4,4103,4103,4103,4103,4103,4103,"get error status and clear""SO_DONTROUTE",5,16,16,,16,,,"just use interface addresses""SO_BROADCAST",6,32,32,,32,,,"permit sending of broadcast messages""SO_SNDBUF",7,4097,4097,,4097,,,"SO_RCVBUF",8,4098,4098,,4098,,,"SO_KEEPALIVE",9,8,8,,8,,,"keep connections alive""SO_OOBINLINE",10,256,256,256,256,256,256,"leave received OOB data in line""SO_LINGER",13,128,128,128,128,128,128,"linger on close if data present""SO_RCVLOWAT",18,4100,4100,,4100,,,"SO_SNDLOWAT",19,4099,4099,,4099,,,"SO_RCVTIMEO",20,4102,4102,,4102,,,"SO_SNDTIMEO",21,4101,4101,,4101,,,"SO_ACCEPTCONN",30,2,2,,2,,,"socket has had listen""SO_USELOOPBACK","#undef",64,64,,64,,,"bypass hardware when possible""SO_REUSEPORT","#undef","#undef",512,,512,,,"allow local address and port reuse""SO_NOREUSEADDR","#undef","#undef","#undef",,4096,,,"prevent local address reuse",,,,,,,,"TCP Options",,,,,,,,"TCP_NODELAY",,1,,,,,,,,,,,,,,,,,,,,,,"IP options",,,,,,,,"IP_TOS",1,3,3,3,3,8,3,"IP_TTL",2,4,4,4,4,16,4,"IP_HDRINCL",3,2,2,2,2,4098,2,"IP_OPTIONS",4,1,1,1,1,1,1,,,,,,,,,"IP_DEFAULT_MULTICAST_LOOP",1,1,1,1,1,1,1,"IP_DEFAULT_MULTICAST_TTL",1,1,1,1,1,1,1,,,,,,,,,"IP_MULTICAST_IF",32,9,9,16,9,2,9,"IP_MULTCAST_TTL",33,10,10,17,10,3,10,"IP_MULTCAST_LOOP",34,11,11,18,11,4,11,"IP_ADD_MEMBERSHIP",35,12,12,19,12,5,12,"IP_DROP_MEMBERSHIP",36,13,13,20,13,6,13,'</body><body package="SpSockets">socketOptionLevels	"^an IdentityDictionary	I return the dictionary mapping each defined socket option level symbol to it's numeric	value.  See socket.h and look for the #define SOL_xxx lines.	If you modify this method, evaluate the following:		'SpSocket resetAllDefinedValues' "	socketOptionLevels isNil 		ifTrue: 			[socketOptionLevels := (IdentityDictionary new)						at: #SOL_SOCKET put: SocketAccessor defaultClass _solSocket;						yourself].	^socketOptionLevels</body><body package="SpSockets">socketOptions	"^an IdentityDictionary	I return the dictionary mapping each defined socket option symbol to it's numeric	value.  See socket.h and look for the #define SO_xxx lines.	If you modify this method, evaluate the following:		'SpSocket resetAllDefinedValues' "	socketOptions isNil 		ifTrue: 			[socketOptions := (IdentityDictionary new)						at: #SO_REUSEADDR put: SocketAccessor defaultClass _soReuseaddr;						yourself].	^socketOptions</body><body package="SpSockets">socketTypes	"^an IdentityDictionaryI return the dictionary mapping each defined socket type symbol to it's numeric value.  See socket.h and look for the #define SOCK_xxx lines.Since the hard work on the various codes has been done by the nice people at Cincom, I just delegate to Socket Accessor for the actual values here in VisualWorks.If you modify this method, evaluate the following:		'SpSocket resetAllDefinedValues' "	socketTypes isNil 		ifTrue: 			[socketTypes := (IdentityDictionary new)						at: #SOCK_STREAM put: SocketAccessor SOCK_STREAM;						yourself].	^socketTypes</body></methods><methods><class-id>SpSocket class</class-id> <category>instance creation</category><body package="SpSockets">connectToServerOnHost: hostName port: portNumber 	"^an OSkSocket 	I return a new instance of myself which represents a socket connecter to a server listening on portNumber at hostName."	| newSocket |	newSocket := self newTCPSocket.	newSocket connectTo: (SpIPAddress hostName: hostName port: portNumber).	^newSocket</body><body package="SpSockets">connectToServerOnHost: hostName port: portNumber timeout: aNuberOfMilliseconds 	"^an OSkSocket 	I return a new instance of myself which represents a socket connecter to a server listening on portNumber at hostName."	| newSocket |	newSocket := self newTCPSocket.	newSocket connectTo: (SpIPAddress hostName: hostName port: portNumber)		timeout: aNuberOfMilliseconds.	^newSocket</body><body package="SpSockets">newTCPSocket	"^an OSkSocket	I create and return a new socket configured to be of a streaming type handle the 	IPv4 protocol family (default protocol).  This is a tcp_socket (see man 7 ip)."	^self forDomain: #PF_INET type: #SOCK_STREAM</body><body package="SpSockets">newUDPClient	^SpUDPSocket newClient</body><body package="SpSockets">newUDPserverOnPort: portNumber 	^SpUDPSocket newServerOnPort: portNumber</body></methods><methods><class-id>SpSocket class</class-id> <category>instance creation - private</category><body package="SpSockets">forDomain: aCommunicationsDomain type: aSocketType 	"^an OSkSocket	Default the protocol to zero - this is the default  in the Spec anyway.  See man socket.."	^self 		forDomain: aCommunicationsDomain		type: aSocketType		protocol: 0</body><body package="SpSockets">forDomain: aDomainSymbol type: aSocketTypeSymbol protocol: aProtocolNumber 	"^an OSkSocket	Equivalent of int socket(int domain, int type, int protocol);  see man socket.	I return a new instance of myself that represents a socket configured for the	specified domain type and protocol ."	| newNativeSocket |	newNativeSocket := SocketAccessor 				family: (self protocolFamilies at: aDomainSymbol)				type: (self socketTypes at: aSocketTypeSymbol).	^self new 		onNativeSocket: newNativeSocket		forDomain: aDomainSymbol		type: aSocketTypeSymbol		protocol: aProtocolNumber</body><body package="SpSockets">socketPairForDomain: aCommunicationsDomain type: aSocketType 	"^an OSkSocket	see: man socketpair	Default the protocol to zero - this is the default  in the Spec anyway. "	^self 		socketPairForDomain: aCommunicationsDomain		type: aSocketType		protocol: 0</body><body package="SpSockets">socketPairForDomain: aDomainSymbol type: aTypeSymbol protocol: aProtocolNumber 	"^an OSkSocket	See: man socketpair	Equivalent of int socketpair(int d, int type, int protocol, int sv[2]); 	I return and array containing two new instances of myself each representing	one end of a connection.	Note that VW does not let one specify the domain/type/protocol of the pair, but	they seem to be redundant anyway since #PF_UNIX (aka #PF_LOCAL.) is all that	is supported by BSD sockets (in Linux) anyway."	^SocketAccessor openPair collect: 			[:newNativeSocket | 			self new 				onNativeSocket: newNativeSocket				forDomain: aDomainSymbol				type: aTypeSymbol				protocol: aProtocolNumber]</body></methods><methods><class-id>SpUDPSocket</class-id> <category>initialize-release</category><body package="SpSockets">asClient	underlyingSocket := SocketAccessor newUDP.	^self</body><body package="SpSockets">asServerOnPort: portNumber 	underlyingSocket := SocketAccessor newUDPserverAtPort: portNumber.	^self</body></methods><methods><class-id>SpUDPSocket</class-id> <category>services-io</category><body package="SpSockets">readWaitWithTimeoutMs: anInteger 	"^a BooleanI return true if anInteger milliseconds have passed without a read becoming possible, otherwise false.  iow, false means you can read and true means you can't."	^self underlyingSocket readWaitWithTimeoutMs: anInteger</body><body package="SpSockets">receiveFrom: originatorAddress buffer: octetBuffer start: startIndex for: aNumberOfOctets 	"^an IntegerI read octets into octetBuffer from startIndex up to a maximim of aNumberOfOctets.  I modify originatorAddress with the host and port of the sender of this data.  I return the number of octets actually read into the octetBuffer."	| vwSocketAddress actuallyRead |	vwSocketAddress := IPSocketAddress new.	actuallyRead := self underlyingSocket 				receiveFrom: vwSocketAddress				buffer: octetBuffer				start: startIndex				for: aNumberOfOctets.	originatorAddress host: vwSocketAddress hostAddress		port: vwSocketAddress port.	^actuallyRead</body><body package="SpSockets">sendTo: targetAddress buffer: octetBuffer start: startIndex for: aNumberOfOctets 	"^an IntegerI return the integer number of octets actually written."	^self underlyingSocket 		sendTo: targetAddress asNativeSocketAddress		buffer: octetBuffer		start: startIndex		for: aNumberOfOctets</body><body package="SpSockets">writeWait	"^selfI just wait until I'm sure my underlying socket is able at accept more written octets."	self underlyingSocket writeWait.	^self</body></methods><methods><class-id>SpUDPSocket class</class-id> <category>instance creation</category><body package="SpSockets">newClient	^self new asClient</body><body package="SpSockets">newServerOnPort: portNumber 	^self new asServerOnPort: portNumber</body></methods><methods><class-id>SpMD5Digest class</class-id> <category>encoding</category><body package="SpEnvironmental">byteHash: bytes 	"^a ByteArray	Just return the digest for bytes by delegating to  the MD5 class."	^self currentMD5Class byteHash: bytes</body><body package="SpEnvironmental">currentMD5Class	"^a Class	Return the MD5 class to be used in this environment.  The MD5 class was moved ."	"NativeMD5Digest currentMD5Class"	currentMD5Class isNil 		ifTrue: 			[currentMD5Class := 'Security.MD5' asQualifiedReference 						ifDefinedDo: [:theClass | theClass]						elseDo: ['Net.MD5' asQualifiedReference value]].	^currentMD5Class</body></methods><methods><class-id>SpFilesCodeForSqueak class</class-id> <category>code strings</category><body package="SpFiles">codeString	"^a String	I return the string which is the source code for the GemStone compatibility classes."	"(Filename named: 'SpFiles-squeak.st') writeStream nextPutAll: self codeString; close"	^'Object subclass: #SpFilename	instanceVariableNames: ''underlyingFilename''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpFiles''!!SpFilename methodsFor: ''testing'' stamp: ''BB 1/25/2006 15:56''!exists	"^a BoolianI return true if the file I represent actually exists, otherwise false."	^self underlyingFilename exists! !!SpFilename methodsFor: ''private'' stamp: ''BB 1/25/2006 15:56''!underlyingFilename	"^a FilenameI return the Filename instance that I am a wrapper for."	^underlyingFilename! !Object subclass: #SpFileStream	instanceVariableNames: ''underlyingStream filename''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpFiles''!!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:00''!atEnd	^self underlyingStream atEnd! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:00''!close	^self underlyingStream close! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:00''!closed	^self underlyingStream closed! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:01''!cr	^self underlyingStream cr! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:01''!flush	^self underlyingStream flush! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:01''!next	^self underlyingStream next! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:01''!nextPutAll: aCollection 	^self underlyingStream nextPutAll: aCollection! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:01''!nextPut: anObject 	^self underlyingStream nextPut: anObject! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:01''!peek	^self underlyingStream peek! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:01''!position	^self underlyingStream position! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:02''!position: aNumber	^self underlyingStream position: aNumber! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:02''!skip: anInteger	^self underlyingStream skip: anInteger! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:02''!store: anObject 	^self underlyingStream store: anObject! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:02''!throughAll: aCollection	^self underlyingStream throughAll: aCollection! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:05''!upToAll: aCollection	^self underlyingStream upToAll: aCollection! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:05''!upToEnd	^self underlyingStream upToEnd! !!SpFileStream methodsFor: ''services'' stamp: ''BB 1/25/2006 16:02''!upTo: anObject	^self underlyingStream upTo: anObject! !!SpFileStream methodsFor: ''initialize-release'' stamp: ''BB 1/25/2006 15:58''!appendingToFilename: anOSkFilename 	filename := anOSkFilename asString.	underlyingStream := anOSkFilename underlyingFilename appendStream.	underlyingStream lineEndTransparent.	^self! !!SpFileStream methodsFor: ''initialize-release'' stamp: ''BB 1/25/2006 15:58''!readingFromFileNamed: aString 	"^selfI initialize myself to write to a file named aString."	filename := aString.	underlyingStream := (FileUrl named: aString) readStream.	underlyingStream lineEndTransparent.	^self! !!SpFileStream methodsFor: ''initialize-release'' stamp: ''BB 1/25/2006 15:58''!readingFromFilename: anOSkFilename 	filename := anOSkFilename asString.	underlyingStream := anOSkFilename underlyingFilename readStream.	underlyingStream lineEndTransparent.	^self! !!SpFileStream methodsFor: ''initialize-release'' stamp: ''BB 1/25/2006 16:00''!writingToFileNamed: aString 	"^selfI initialize myself to write to a file named aString."	filename := aString.	underlyingStream := (FileUrl named: aString) writeStream.	underlyingStream lineEndTransparent.	^self! !!SpFileStream methodsFor: ''initialize-release'' stamp: ''BB 1/25/2006 15:59''!writingToFilename: anOSkFilename 	filename := anOSkFilename asString.	underlyingStream := anOSkFilename underlyingFilename writeStream.	underlyingStream lineEndTransparent.	^self! !!SpFileStream methodsFor: ''accessing'' stamp: ''BB 1/25/2006 15:57''!contentsStream	^self underlyingStream contents readStream! !!SpFileStream methodsFor: ''accessing'' stamp: ''BB 1/25/2006 15:57''!filename	^filename! !!SpFileStream methodsFor: ''accessing'' stamp: ''BB 1/25/2006 15:57''!filename: anObject	filename := anObject! !!SpFileStream methodsFor: ''accessing'' stamp: ''BB 1/25/2006 15:58''!underlyingStream	^underlyingStream! !'</body></methods><methods><class-id>SpTimesCodeForGemStone class</class-id> <category>code strings</category><body package="SpTimes">codeString	"^a String	I return the string which is the source code for the OpenSkills GemStone time classes."	"(Filename named: 'SpTimes.gs') writeStream nextPutAll: self codeString; close"	^'!! From ! GEMSTONE: 6.1, Thu Apr 17 20:11:38 US/Pacific 2003; IMAGE: GemStone v6.1 kernel classes filein completed at 17/04/2003 20:22:36! GemStone v6.1 kernel classes filein of stripped sources completed at 17/04/2003 20:31:50! ! On June 26, 2007, 2:22:54 am!!! SymbolDictionary ''SpTimes''!run| symList newDict |symList := System myUserProfile symbolList.symList do: [ :element |    (element includesKey: #SpTimes)        ifTrue: [ ^element ]].newDict := SymbolDictionary new.newDict at: #SpTimes put: newDict.System myUserProfile insertDictionary: newDict at: 1.^newDict%doit(Object subclass: ''SpDate''  instVarNames: #( underlyingDate)  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpTimes  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''SpTimestamp''  instVarNames: #( underlyingTimestamp)  classVars: #()  classInstVars: #( threeCharacterWeekDayName)  poolDictionaries: #[]  inDictionary: SpTimes  constraints: #[]  instancesInvariant: false  isModifiable: true).%doitSpDate immediateInvariant.%doitSpTimestamp immediateInvariant.%! Remove existing behavior from SpDatedoitSpDate removeAllMethods.SpDate class removeAllMethods.%! ------------------- Class methods for SpDatecategory: ''instance creation''classmethod: SpDatefromDays: numberOfDays	"Answer with an instance of Date that is dayCount days since 1901 began."	"This is based on the VisualWorks implementation."	| aDate correction |	aDate := self		newDay: 1 + (numberOfDays rem: 1461)							"There are 1461 days in a 4-year cycle.							 This doesn''t handle leap-centuries quite right:							 we fix this up below."		year: 1901 + ((numberOfDays quo: 1461) * 4).	"Now correct for leap-centuries."	correction := numberOfDays - aDate asDays.	^correction = 0		ifTrue: [aDate]		ifFalse: [aDate addDays: correction]%category: ''instance creation''classmethod: SpDatefromISO8610Stream: aStream 	| date |	date := SpExceptionContext 				for: [self parseDateFromISO8601Stream: aStream]				on: SpError				do: [:ex | nil].	^date isNil ifTrue: [nil] ifFalse: [self onDate: date]%category: ''instance creation''classmethod: SpDatefromISO8610String: aString	^self fromISO8610Stream: aString readStream%category: ''instance creation''classmethod: SpDatenewDay: julianDay year: year"^an SpDateI return a new instance of myself."	^self onDate: (Date newDay: julianDay year: year)%category: ''instance creation''classmethod: SpDateonDate: aDate	^self new onDate: aDate%category: ''instance creation''classmethod: SpDatetoday	^self onDate: Date today%category: ''private''classmethod: SpDateintegerOfLength: aLength FromString: aString 	"^an Integer or nil	I parse an integer from aString, if I have problems I return nil.  I make sure	the string form of the integer is exactly aLength characters long."	"SpDate integerOfLength: 4 FromString: ''2004''"	^(aString size == aLength and: 			[(aString asOrderedCollection select: [:aDigit | aDigit isDigit not]) 				isEmpty]) 		ifFalse: [nil]		ifTrue: [aString asNumber]%category: ''private''classmethod: SpDateparseDateFromISO8601Stream: sourceStream 	"^a Date or nil	I parse an ISO 8601 date from sourceStream.  If there are any parsing	problems, I return nil."	"SpDate parseDateFromISO8601Stream: (ReadStream on: ''2004-01-42'')"	| yyyy mm dd |	yyyy := self integerOfLength: 4 FromString: (sourceStream upTo: $-).	mm := self integerOfLength: 2 FromString: (sourceStream upTo: $-).	sourceStream atEnd ifFalse: [		dd := self integerOfLength: 2 FromString: sourceStream upToEnd].	(yyyy isNil or: [mm isNil or: [dd isNil]]) ifTrue: [^nil].	^SpExceptionContext 		for: 			[Date 				newDay: dd				monthNumber: mm				year: yyyy]		on: SpError		do: [:ex | nil]%! ------------------- Instance methods for SpDatecategory: ''accessing''method: SpDateunderlyingDate	^underlyingDate%category: ''comparing''method: SpDate&lt; anotherSpDate         "^a Boolean        Answer true if anotherSpDate is less (i.e. earlier) than me."        ^self underlyingDate &lt; anotherSpDate underlyingDate%category: ''comparing''method: SpDate&lt;= anotherOSkDate 	"^a Boolean	Answer true if anotherOSkDate is greater (i.e. later) than me."	^self underlyingDate &lt;= anotherOSkDate underlyingDate%category: ''comparing''method: SpDate= anotherSpDate 	"^a Boolean	Answer true if anotherSpDate is equivalent to me."	^self underlyingDate = anotherSpDate underlyingDate%category: ''comparing''method: SpDate&gt; anotherSpDate        "^a Boolean        Answer true if anotherSpDate is greater (i.e. later) than me."        ^self underlyingDate &gt; anotherSpDate underlyingDate%category: ''comparing''method: SpDate&gt;= anotherOSkDate 	"^a Boolean	Answer true if anotherOSkDate is greater (i.e. later) than me."	^self underlyingDate &gt;= anotherOSkDate underlyingDate%category: ''comparing''method: SpDatehash	"^an Object"	^self underlyingDate hash%category: ''comparing''method: SpDatemax: anSpDate 	^self &gt; anSpDate ifTrue: [self] ifFalse: [anSpDate]%category: ''comparing''method: SpDatemin: anSpDate 	^self &lt; anSpDate ifTrue: [self] ifFalse: [anSpDate]%category: ''converting''method: SpDateasDays	"^an Integer	I return the integer number of days between January 1, 1901 and	the date I represent. 	This is the VisualWorks implementation."	| yearIndex |	yearIndex := self year - 1901.	^yearIndex * 365  "elapsed years"		+ (yearIndex // 4)  "ordinary leap years"		+ ((yearIndex + 300) // 400)  "leap centuries, first one is 2000, i.e. yearIndex = 99"		- (yearIndex // 100)  "non-leap centuries"		+ self julianDay - 1%category: ''initialize-release''method: SpDateonDate: aDate 	underlyingDate := aDate.	^self%category: ''printing''method: SpDateasISO8610String	|targetStream|	targetStream := WriteStream on: String new.	self asISO8610StringOn: targetStream.	^targetStream contents%category: ''printing''method: SpDateasISO8610StringOn: aStream 	aStream		nextPutAll: self underlyingDate year printString;		nextPut: $-.	self underlyingDate monthIndex &lt; 10 ifTrue: [aStream nextPut: $0].	aStream		nextPutAll: self underlyingDate monthIndex printString;		nextPut: $-.	self underlyingDate dayOfMonth &lt; 10 ifTrue: [aStream nextPut: $0].	aStream nextPutAll: self underlyingDate dayOfMonth printString.	^self%category: ''services''method: SpDateaddDays: anInteger	^self class onDate: (self underlyingDate addDays: anInteger)%category: ''services''method: SpDateaddYears: anInteger 	"^an OSkDateI don''t change the date I represent.  Rather, I create a new date which represents my date offset by anInteger years.  If we are adding years to the 29th Feb, we need to worry about leap years. "	^self class onDate: (self underlyingDate addYears: anInteger)%category: ''services''method: SpDatejulianDay"^an IntegerI return my julian day number.  Jan 1st is 1."	^self underlyingDate dayOfYear%category: ''services''method: SpDateyear"^an IntegerI return my year as an Integer."	^self underlyingDate year%! Remove existing behavior from SpTimestampdoitSpTimestamp removeAllMethods.SpTimestamp class removeAllMethods.%! ------------------- Class methods for SpTimestampcategory: ''instance creation''classmethod: SpTimestampfromDate: aDate andTime: aTime 	^self new fromDate: aDate andTime: aTime%category: ''instance creation''classmethod: SpTimestampfromRFC1123String: aString 	"^an SpTimestamp"	| sourceStream dd mmm yyyy time |	^SpExceptionContext 		for: 			[sourceStream := ReadStream on: aString.			sourceStream upTo: Character space.			dd := sourceStream upTo: Character space.			mmm := sourceStream upTo: Character space.			yyyy := sourceStream upTo: Character space.			time := sourceStream upTo: Character space.			self fromDate: (Date 						newDay: dd asNumber						month: mmm						year: yyyy asNumber)				andTime: (Time fromString:  time)]		onAnyExceptionDo: 			[:exception | SpError raiseSignal: ''Error parsing RFC1123 date: '' , aString]%category: ''instance creation''classmethod: SpTimestampnow	"^an SpTimestamp	I return a new instance of myself which represents the time now in the	UTC (GMT ish) time zone."	^self new asNowUTC%category: ''statics''classmethod: SpTimestampthreeCharacterWeekDayNames"^an ArrayI return the array of strings which are the three character abriviations of the names of the days of the week.  Starting on Monday."	^#(''Mon'' ''Tue'' ''Wed'' ''Thu'' ''Fri'' ''Sat'' ''Sun'')%! ------------------- Instance methods for SpTimestampcategory: ''comparing''method: SpTimestamp&lt;= anSpTimeStamp 	^self underlyingTimestamp &lt;= anSpTimeStamp underlyingTimestamp%category: ''comparing''method: SpTimestamp= anSpTimeStamp^self underlyingTimestamp = anSpTimeStamp underlyingTimestamp%category: ''comparing''method: SpTimestamp&gt; anSpTimeStamp^self underlyingTimestamp &gt; anSpTimeStamp underlyingTimestamp%category: ''initialize-release''method: SpTimestampasNowUTC	"^self	Cheat for now and assumen that DateTime&gt;&gt;now is UTC."	underlyingTimestamp := DateTime now.	^self%category: ''initialize-release''method: SpTimestampfromDate: aDate andTime: aTime 	"^selfInitialize myself on the basis of aDate and aTime."	underlyingTimestamp := DateTime newWithDate: aDate time: aTime.	^self%category: ''printing''method: SpTimestampasRFC1123String	"^a String	c.f  &gt;&gt;asRFC1123StringOn: "	| targetStream |	targetStream := WriteStream on: String new.	self asRFC1123StringOn: targetStream.	^targetStream contents%category: ''printing''method: SpTimestampasRFC1123StringOn: targetStream	"^a self	I write a string representing my underlying DataTime of the form:		Tue, 23 Mar 2004 15:24:12 GMT	to targetStream"	"SpTimestamp now asRFC1123String"	targetStream		nextPutAll: (self class threeCharacterWeekDayNames 					at: self underlyingTimestamp dayOfWeek);		nextPutAll: '', '';		nextPutAll: (self underlyingTimestamp					asStringUsingFormat: #(1 2 3 $  2 1 $: true true false));		nextPutAll: '' GMT''.	^self%category: ''private''method: SpTimestampunderlyingTimestamp	^underlyingTimestamp%'</body></methods><methods><class-id>SpEnvironment class</class-id> <category>testing</category><body package="SpEnvironmental">isDolphin	^false</body><body package="SpEnvironmental">isGemStone	^false</body><body package="SpEnvironmental">isGNU	^false</body><body package="SpEnvironmental">isHeadless	^self isVisualWorks and: 			[(Smalltalk bindingFor: #HeadlessImage) notNil 				and: [HeadlessImage default isHeadless]]</body><body package="SpEnvironmental">isSqueak	^false</body><body package="SpEnvironmental">isVisualAge	^false</body><body package="SpEnvironmental">isVisualSmalltalk	^false</body><body package="SpEnvironmental">isVisualWorks	^true</body></methods><methods><class-id>SpEnvironment class</class-id> <category>os commands</category><body package="SpEnvironmental">runShellCommandString: aCommandString 	^UnixProcess cshOne: aCommandString</body></methods><methods><class-id>SpEnvironment class</class-id> <category>queries</category><body package="SpEnvironmental">allSubclassesOf: aClass"^an ArrayI return the array of classes which are subclasses of aClass."	^aClass allSubclasses asArray</body></methods><methods><class-id>SpEnvironment class</class-id> <category>image shutdown</category><body package="SpEnvironmental">addImageShutdownTask: aBlock for: anObject 	"^self	I add aBlock to the list of actions and note that this is for anObject.  If there are	currenty no tasks, I add myself as an ObejctMemort dependant."	self imageShutdownTaskBlocks isEmpty 		ifTrue: [ObjectMemory addDependent: self].	self imageShutdownTaskBlocks at: anObject put: aBlock.	^self</body><body package="SpEnvironmental">imageShutdownTaskBlocks	imageShutdownTaskBlocks isNil 		ifTrue: [imageShutdownTaskBlocks := IdentityDictionary new].	^imageShutdownTaskBlocks</body><body package="SpEnvironmental">removeShutdownActionFor: anObject 	"^self	I remove the task block for an object it it has one.  If the collection of tasks is now	empty, I remove myself as an ObjectMemory dependent."	(self imageShutdownTaskBlocks includesKey: anObject) 		ifTrue: 			[imageShutdownTaskBlocks removeKey: anObject.			imageShutdownTaskBlocks isEmpty 				ifTrue: [ObjectMemory removeDependent: self]].	^self</body><body package="SpEnvironmental">update: aspect with: aParameter from: sender 	(sender == ObjectMemory and: [aspect == #aboutToSnapshot]) 		ifTrue: 			[self imageShutdownTaskBlocks values 				do: [:aShutdownTask | aShutdownTask value]].	^self</body></methods><methods><class-id>SpEnvironment class</class-id> <category>services</category><body package="SpEnvironmental">associationWithKey: aKey value: aValue 	"^an Association"	^Association key: aKey value: aValue</body><body package="SpEnvironmental">characterFromInteger: anInteger 	^Character value: anInteger</body><body package="SpEnvironmental">integerFromString: aString"^an IntegerWe need this because of what looks like a bug in GemStone's String&gt;&gt;asNumber (e.g. '16rFF' -&gt; 1.6000000000000000E+01, not 255)."	^aString asNumber</body><body package="SpEnvironmental">readIntegerFrom: aStream radix: aRadix 	"^an Integer"	^Number readIntegerFrom: aStream radix: aRadix</body><body package="SpEnvironmental">streamStartPosition	"^an IntegerStreams start at position 0 in VisualWorks, and position 1 in GemStone(!)."	^0</body><body package="SpEnvironmental">writeStackDumpForException: anException context: aContext to: targetStream 	"^selfIf the RuntimePackager dumper is available I use that."	'RuntimePackager.RuntimeImageDumper' asQualifiedReference isDefined 		ifTrue: 			[((RuntimePackager.RuntimeImageDumper new)				instVarAt: 1 put: targetStream;				yourself) dumpExceptionReport: anException context: aContext]		ifFalse: [aContext printSenderStackOn: targetStream max: 200].	^self</body></methods><methods><class-id>SpEnvironment class</class-id> <category>development</category><body package="SpEnvironmental">madeObsoleteBy: aBlock 	"^an ObjectI cause halt the code and ask the developer to use the code in aBlock, rather than the obsolete code."	(self isHeadless or: [self isGemStone]) 		ifFalse: 			[1 				halt: 'please use the code in the block, not the obsolete code - thanks.'].	^aBlock value</body><body package="SpEnvironmental">workInProgress	"^selfThis method does nothing, but can be used to 'mark' methods still needing work.  Simply send this message, and use browse senders to find things still in need of attention.A simpler way to do this is to add '#wip yourself' to the method.  Then you can look for all references to the Symbol #wip."	^self</body></methods><methods><class-id>SpEnvironment class</class-id> <category>compiling</category><body package="SpEnvironmental">evaluate: aString in: anEnvironment	^Compiler 		evaluate: aString		for: nil		in: anEnvironment		notifying: nil		logged: false</body><body package="SpEnvironmental">evaluate: aString receiver: anObject in: anEnvironment 	^Compiler new 		evaluate: aString		in: nil		allowReceiver: true		receiver: anObject		environment: anEnvironment		notifying: nil		ifFail: []</body></methods><methods><class-id>SpEnvironment class</class-id> <category>hex</category><body package="SpEnvironmental">byteArrayFromHexString: aString 	^ByteArray fromHexString: aString</body><body package="SpEnvironmental">hexStringFromByteArray: aByteArray 	^aByteArray asHexString</body></methods><methods><class-id>SpEnvironment class</class-id> <category>garbage collection</category><body package="SpEnvironmental">collectGarbage	"^selfPerform a light weight GC"	ObjectMemory quickGC.	^self</body><body package="SpEnvironmental">compactingGC	"^selfperform a full compacting GC."	ObjectMemory compactingGC.	^self</body></methods><methods><class-id>SpFilename</class-id> <category>services</category><body package="SpFiles">appendStream	"^an OSkFileStreamI create an append stream on the file I represent."	^SpFileStream appendingToFilename: self</body><body package="SpFiles">asString	^self underlyingFilename asString</body><body package="SpFiles">delete	^self underlyingFilename delete</body><body package="SpFiles">readStream	"^an OSkFileStreamI create a read stream on the file I represent."	^SpFileStream readingFromFilename: self</body><body package="SpFiles">writeStream	"^an OSkFileStreamI create a write stream on the file I represent."	^SpFileStream writingToFilename: self</body></methods><methods><class-id>SpFilename</class-id> <category>private</category><body package="SpFiles">underlyingFilename	"^a FilenameI return the Filename instance that I am a wrapper for."	^underlyingFilename</body></methods><methods><class-id>SpFilename</class-id> <category>initialize-release</category><body package="SpFiles">named: aString 	"^selfI initialize myself to represent the filename identified by aString."	underlyingFilename := Filename named: aString.	^self</body></methods><methods><class-id>SpFilename</class-id> <category>testing</category><body package="SpFiles">exists	"^a BoolianI return true if the file I represent actually exists, otherwise false."	^self underlyingFilename exists</body></methods><methods><class-id>SpFilename class</class-id> <category>instance creation</category><body package="SpFiles">named: aString 	"^an OSkFilenameI create a new instance of myself to represent the filename identified by aString."	^self new named: aString</body></methods><methods><class-id>SpExceptionCodeForSqueak class</class-id> <category>code strings</category><body package="SpExceptions">codeString	"^a String	I return the string which is the source code for the GemStone compatibility classes."	"(Filename named: 'SpExceptions-squeak.st') writeStream nextPutAll: self codeString; close"	^'Error subclass: #SpAbstractError	instanceVariableNames: ''parameter''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpExceptions''!!SpAbstractError methodsFor: ''accessing'' stamp: ''BB 1/25/2006 21:52''!errorString	^self messageText! !!SpAbstractError methodsFor: ''accessing'' stamp: ''BB 1/23/2006 22:03''!parameter	^parameter ! !!SpAbstractError methodsFor: ''accessing'' stamp: ''BB 1/23/2006 22:03''!parameter: anObject 	parameter := anObject! !!SpAbstractError methodsFor: ''signalling'' stamp: ''BB 1/23/2006 22:11''!raiseSignal	"Raise an an exception."	^ self signal! !!SpAbstractError methodsFor: ''signalling'' stamp: ''BB 1/25/2006 22:02''!raiseSignal: aString 	"Raise an an exception."	^ self signal: aString! !!SpAbstractError methodsFor: ''priv handling'' stamp: ''BB 1/23/2006 22:16''!isResumable	"Determine whether an exception is resumable."	^self class mayResume! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SpAbstractError class	instanceVariableNames: ''''!!SpAbstractError class methodsFor: ''signalling'' stamp: ''BB 1/23/2006 22:08''!raiseSignal	"Raise an an exception."	^ self signal! !!SpAbstractError class methodsFor: ''signalling'' stamp: ''BB 1/23/2006 21:24''!raiseSignal: aString 	"Raise an an exception."	^ self signal: aString! !!SpAbstractError class methodsFor: ''testing'' stamp: ''BB 1/23/2006 22:17''!mayResume	^false! !SpAbstractError subclass: #SpError	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpExceptions''!Object subclass: #SpExceptionContext	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpExceptions''!!SpExceptionContext commentStamp: ''&lt;historical&gt;'' prior: 0!Exceptions vary quite a bit between Smalltalk implementaions, despite the presence of the ANSI Smalltalk specification.  This class representss a portable exception context in which a block can be executed, exceptions trapped and handlers defined.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SpExceptionContext class	instanceVariableNames: ''''!!SpExceptionContext class methodsFor: ''native exceptions'' stamp: ''BB 1/19/2006 15:48''!brokenPipeException	"I return the exception that get''s thrown when a socket connection gets 	broken."	^ProtocolClientError! !!SpExceptionContext class methodsFor: ''instance creation'' stamp: ''BB 1/19/2006 15:45''!for: aBlock onAnyExceptionDo: exceptionBlock 	"^an Object 	I execute aBlock and if there is any exception I evaluate exceptionBlock.  Essentially, I look out for the most abstract kind of exception which , of course, will vary between Smalltalk implementations."	^aBlock on: Exception do: exceptionBlock! !!SpExceptionContext class methodsFor: ''instance creation'' stamp: ''BB 1/19/2006 15:44''!for: aBlock on: anException do: exceptionBlock 	"^an Object 	I return the result of evaluating aBlock. In VisualWorks and other 	Smalltalks which are ANSI compliant, I delegate to aBlock."	^aBlock on: anException do: exceptionBlock! !'</body></methods><methods><class-id>SpSocketAddress class</class-id> <category>instance creation</category><body package="SpSockets">on: subjectAddress for: aSocket 	"^an OSkSocketAddress	Well, in the future there may be more than one kind of socket address,	but for now there is just OSkIPAddress, so I return one of those on the 	details embodied in the subjectAddress. 	No use is made of aSocket as yet, but it will be useful when there	are more kinds of socket address supported."	^SpIPAddress host: subjectAddress hostAddress port: subjectAddress port</body></methods><methods><class-id>SpIPAddress</class-id> <category>accessing</category><body package="SpSockets">hostAddress	^hostAddress</body><body package="SpSockets">portNumber	^portNumber</body></methods><methods><class-id>SpIPAddress</class-id> <category>printing</category><body package="SpSockets">hostAddressString	| targetStream |	targetStream := String new writeStream.	targetStream		nextPutAll: (self hostAddress at: 1) printString;		nextPut: $.;		nextPutAll: (self hostAddress at: 2) printString;		nextPut: $.;		nextPutAll: (self hostAddress at: 3) printString;		nextPut: $.;		nextPutAll: (self hostAddress at: 4) printString.	^targetStream contents</body></methods><methods><class-id>SpIPAddress</class-id> <category>initialize-release</category><body package="SpSockets">host: aHostAddress port: aPortNumber 	hostAddress := aHostAddress.	portNumber := aPortNumber.	^self</body></methods><methods><class-id>SpIPAddress</class-id> <category>services - private</category><body package="SpSockets">asNativeSocketAddress	"^an IPSocketAddress	I return a VisualWorks IPSocketAddress which represents the same IP address I do."	^IPSocketAddress hostAddress: self hostAddress port: self portNumber</body></methods><methods><class-id>SpIPAddress class</class-id> <category>instanceCreation</category><body package="SpSockets">host: aHostAddress port: aPortNumber 	"^an OSkSocketAddress	I create a new instance of myself which represents an IP address/port combination	(a TCP/IP address, really).  Note that aHostAddress must be a four element byte 	array (e.g. #[127 0 0 1]) ."	^self new host: aHostAddress port: aPortNumber</body><body package="SpSockets">hostName: aHostNameString port: aPortNumber 	"^an OSkSocketAddress	I translate aHostNameString to an IP address and then create	a new instance of myself with &gt;&gt;host:port:"	^self host: (IPSocketAddress hostAddressByName: aHostNameString)		port: aPortNumber</body></methods><methods><class-id>SpNonBlockingSocketReadRequestPostCake</class-id> <category>services-io</category><body package="SpSockets">errorSignalFor: currentResponse	"^a Signal instance or an ANSI exception subclass instance"	| errorSignal |	errorSignal := (self underlyingSocket class errorSignalFor: currentResponse) new.	errorSignal		parameter: currentResponse;		errorString: (OSErrorHolder errorDescriptionFor: currentResponse parameter).	^errorSignal</body><body package="SpSockets">recvInto: aByteArray startingAt: startIndex for: aNumberOfOctets	" Read aNumberOfOctets into aByteArray starting at startIndex.Return the number of octets actually read.  A return value of 0indicates that no data was available for reading without blocking(i.e., an EWOULDBLOCK condition).  An EOF condition (the primitivereturns 0) is indicated by raising a signal."	^self doThenComplete: 			[| currentResponse |			currentResponse := self underlyingSocket primReadOrErrorCodeInto: aByteArray startingAt: startIndex for: aNumberOfOctets.			currentResponse isError				ifTrue: 					[(self underlyingSocket class restartableError: currentResponse)						ifTrue: [0]						ifFalse: 							[socket close.							SpSocketError signalWith: (self errorSignalFor: currentResponse)]]				ifFalse: 					[currentResponse &gt; 0						ifTrue: [currentResponse]						ifFalse: 							[socket close.							SpSocketShutDownByPeer raiseSignal]]]</body></methods><methods><class-id>SpEnvironmentalCodeForSqueak class</class-id> <category>code strings</category><body package="SpEnvironmental">codeString	"^a String	I return the string which is the source code for the GemStone compatibility classes."	"(Filename named: 'SpEnvironmental-squeak.st') writeStream nextPutAll: self codeString; close"	^'Object subclass: #SpEnvironment	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpEnvironmental''!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SpEnvironment class	instanceVariableNames: ''''!!SpEnvironment class methodsFor: ''services'' stamp: ''BB 1/23/2006 08:48''!streamStartPosition	"^an Integer	Streams start at position 0 in VisualWorks &amp; Squeak, and position 1 in	GemStone(!!). "	^ 0! !!SpEnvironment class methodsFor: ''services'' stamp: ''BB 1/30/2006 17:11''!writeStackDumpForException: exception to: targetStream 	targetStream nextPutAll: ''SpEnvironment class&gt;&gt;writeStackDumpForException:to: does not work yet :-/''! !!SpEnvironment class methodsFor: ''testing'' stamp: ''BB 1/24/2006 11:46''!isGemStone	^false! !!SpEnvironment class methodsFor: ''testing'' stamp: ''BB 1/25/2006 22:07''!isHeadless	^false! !!SpEnvironment class methodsFor: ''testing'' stamp: ''BB 1/24/2006 11:47''!isSqueak	^true! !!SpEnvironment class methodsFor: ''testing'' stamp: ''BB 1/24/2006 11:47''!isVisualWorks	^false! !!SpEnvironment class methodsFor: ''image shutdown'' stamp: ''BB 1/31/2006 22:37''!addImageShutdownTask: aBlock for: anObject ! !Object subclass: #SpStringUtilities	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpEnvironmental''!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SpStringUtilities class	instanceVariableNames: ''''!!SpStringUtilities class methodsFor: ''services-encoding'' stamp: ''BB 1/23/2006 12:02''!bytes: subjectBytes asStringUsingEncodingNames: anEncodingName 	^ subjectBytes asString! !!SpStringUtilities class methodsFor: ''services-encoding'' stamp: ''BB 1/23/2006 11:59''!string: subjectString asBytesUsingEncodingNamed: anEncodingName 	^ subjectString asByteArray! !Object subclass: #SpTranscript	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpEnvironmental''!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SpTranscript class	instanceVariableNames: ''''!!SpTranscript class methodsFor: ''logging'' stamp: ''BB 1/25/2006 22:07''!cr	^ SpEnvironment isHeadless		ifTrue: [self]		ifFalse: [Transcript cr]! !!SpTranscript class methodsFor: ''logging'' stamp: ''BB 1/25/2006 22:08''!nextPutAll: aCollection 	^self show: aCollection! !!SpTranscript class methodsFor: ''logging'' stamp: ''BB 1/25/2006 22:08''!nextPut: anObject 	^self show: (String with: anObject)! !!SpTranscript class methodsFor: ''logging'' stamp: ''BB 1/25/2006 22:07''!show: aString 	^ SpEnvironment isHeadless		ifTrue: [self]		ifFalse: [Transcript show: aString]! !Object subclass: #SpWeakArray	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpEnvironmental''!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SpWeakArray class	instanceVariableNames: ''''!!SpWeakArray class methodsFor: ''instance creation'' stamp: ''BB 1/22/2006 15:58''!new: anInteger 	"^a WeakArray 	I don''t return an instance of myself, I return a real WeakArray."	^WeakArray new: anInteger! !!SpWeakArray class methodsFor: ''instance creation'' stamp: ''BB 1/22/2006 16:01''!withAll: aCollection 	"^a WeakArray 	I don''t return an instance of myself at all. I return a real Weak array."	^ WeakArray withAll: aCollection asArray! !'</body></methods><methods><class-id>SpWeakArray class</class-id> <category>instanceCreation</category><body package="SpEnvironmental">new: anInteger 	"^a WeakArray 	I don't return an instance of myself, I return a real WeakArray."	^WeakArray new: anInteger</body><body package="SpEnvironmental">withAll: aCollection 	"^a WeakArray 	I don't return an instance of myself at all. I return a real Weak array."	^WeakArray withAll: aCollection</body></methods><methods><class-id>SpRandom class</class-id> <category>code strings</category><body package="SpEnvironmental">codeString	"^a String	I return the string which is the source code for the GemStone compatibility classes."	"(Filename named: 'Random.gs') writeStream nextPutAll: self codeString; close"	^'!=========================================================================! Copyright (C) GemStone Systems, Inc. 1986-1998.  All Rights Reserved.!! $Id: random.gs,v 50.9 1998/01/15 23:49:11 darrel Exp $!! Superclass Hierarchy:!   Stream, Object.!!=========================================================================!! From ! GEMSTONE: 6.1, Thu Apr 17 20:11:38 US/Pacific 2003; IMAGE: GemStone v6.1 kernel classes filein completed at 17/04/2003 20:22:36! GemStone v6.1 kernel classes filein of stripped sources completed at 17/04/2003 20:31:50! ! On July 21, 2004, 7:49:40 am!!! SymbolDictionary ''GsRandom''!run| symList newDict |symList := System myUserProfile symbolList.symList do: [ :element |    (element includesKey: #GsRandom)        ifTrue: [ ^element ]].newDict := SymbolDictionary new.newDict at: #GsRandom put: newDict.System myUserProfile insertDictionary: newDict at: 1.^newDict%doit(Stream subclass: ''Random''  instVarNames: #( seed hi lo)  classVars: #( a m q r)  classInstVars: #()  poolDictionaries: #[]  inDictionary: GsRandom  constraints: #[]  instancesInvariant: false  isModifiable: true).%doitRandom immediateInvariant.%! Remove existing behavior from RandomdoitRandom removeAllMethods.Random class removeAllMethods.%! ------------------- Class methods for Randomcategory: ''(as yet unclassified)''classmethod: Randominitialize  "Class initialization"  a := 16807.0.  m := 2147483647.0.  q := m // a.  r := m \\ a.%category: ''For Documentation Installation only''classmethod: RandominstallDocumentation| doc txt |doc := GsClassDocumentation newForClass: self.txt := (GsDocText new) details:''Class Random is a port of Jeff Sutherland''''s implementation of the Park &amp; Miller random number generator.From Jeff Sutherland''''s original posting:"In summary...(this is) a generator which has a full period, isdemonstrably random, and can be implemented correctly on almostany system.  The generator has been exhaustively tested and itscharacteristics are well understood... Moreover, it has become astandard ... subroutine DNUN in the IMSL library and ... DRANDin the simulation language SLAM II...  we feel confident inrecommending this random number generator as a minimal standardagainst which all others should be judged."This code has received minimal testing on an IBM P75 486 machineand may break on a Pentium.  It is written in Enfin Smalltalk buta port to another Smalltalk is trivial.  The validate function worksbut any bugs you find are surely mine.  Send me a note atjsutherland@vmark.com.'' .doc documentClassWith: txt.self description: doc.%category: ''Instance Creation''classmethod: Randomnew ^super new initialize.%category: ''Testing''classmethod: Randomspeed       "Random speed will benchmark the efficiency of random numbergeneration"|rand|rand := self new.^(System millisecondsToRun: [ 1000 timesRepeat: [rand next]  ]) / 1000.0%category: ''Testing''classmethod: RandomtestRandom       "Random testRandom will check your hardware environment"|num|num := Random new initialize.num seed: 1.10000 timesRepeat: [  num next.].(1043618065 = num seed)  ifTrue: [ ^''OK.'' ]  ifFalse: [ ^''Bad result. Fix this generator             by referring to Park &amp; Miller,^M             Communications of the ACM 31:10:1192-1201, 1988.'' ].%! ------------------- Instance methods for Randomcategory: ''Accessing''method: Randomnext "Answer the next random number.""Real Random Number generator Version 2 from Park and Miller, 1988"  hi := seed quo: q.  lo := seed - (q * hi).  seed := (a * lo) - (r * hi).  seed &gt; 0 ifFalse: [    seed := seed + m].  ^ seed / m.%category: ''Accessing''method: Randomseed   "Return the value of the instance variable ''seed''."   ^seed%category: ''accessing''method: Randombetween: min and: max   "Return a random value x such that min &lt;= x &lt; max"  ^(self next * (max - min)) + min%category: ''accessing''method: Randomcontents "Random numbers do not have a contents so provide an error notification." ^self shouldNotImplement: #contents%category: ''accessing''method: Randomflush "Random numbers do not need to flush." ^self shouldNotImplement: #flush%category: ''accessing''method: RandomnextPut: anObject "Random numbers do not implement nextPut: so provide an error notification." ^self shouldNotImplement: #nextPut:%category: ''Initialization''method: Randomseed: aSeed  seed := aSeed.  hi := lo := nil.%category: ''Private''method: Randominitialize  "Initialize an instance, seeded by the time of day"  self seed: System _timeMs%category: ''testing''method: RandomatEnd "Answer false that the stream is not at an end." ^false%run  Random initialize.%'</body></methods><methods><class-id>SpDate</class-id> <category>comparing</category><body package="SpTimes">&lt; anotherOSkDate 	"^a Boolean	Answer true if anotherOSkDate is less (i.e. earlier) than me."	^self underlyingDate &lt; anotherOSkDate underlyingDate</body><body package="SpTimes">&lt;= anotherOSkDate 	"^a Boolean	Answer true if anotherOSkDate is greater (i.e. later) than me."	^self underlyingDate &lt;= anotherOSkDate underlyingDate</body><body package="SpTimes">= anotherOSkDate 	"^a Boolean	Answer true if anotherOSkDate is equivalent to me."	^self underlyingDate = anotherOSkDate underlyingDate</body><body package="SpTimes">&gt; anotherOSkDate 	"^a Boolean	Answer true if anotherOSkDate is greater (i.e. later) than me."	^self underlyingDate &gt; anotherOSkDate underlyingDate</body><body package="SpTimes">&gt;= anotherOSkDate 	"^a Boolean	Answer true if anotherOSkDate is greater (i.e. later) than me."	^self underlyingDate &gt;= anotherOSkDate underlyingDate</body><body package="SpTimes">hash	"^an Object"	^self underlyingDate hash</body><body package="SpTimes">max: anSpDate 	^self &gt; anSpDate ifTrue: [self] ifFalse: [anSpDate]</body><body package="SpTimes">min: anSpDate 	^self &lt; anSpDate ifTrue: [self] ifFalse: [anSpDate]</body></methods><methods><class-id>SpDate</class-id> <category>initialize-release</category><body package="SpTimes">onDate: aDate 	underlyingDate := aDate.	^self</body></methods><methods><class-id>SpDate</class-id> <category>converting</category><body package="SpTimes">asDays	"^an Integer	I return the integer number of days between January 1, 1901 and	the date I represent. "	^self underlyingDate asDays</body></methods><methods><class-id>SpDate</class-id> <category>printing</category><body package="SpTimes">asISO8610String	|targetStream|	targetStream := WriteStream on: String new.	self asISO8610StringOn: targetStream.	^targetStream contents</body><body package="SpTimes">asISO8610StringOn: aStream 	aStream		nextPutAll: self underlyingDate year printString;		nextPut: $-.	self underlyingDate monthIndex &lt; 10 ifTrue: [aStream nextPut: $0].	aStream		nextPutAll: self underlyingDate monthIndex printString;		nextPut: $-.	self underlyingDate dayOfMonth &lt; 10 ifTrue: [aStream nextPut: $0].	aStream nextPutAll: self underlyingDate dayOfMonth printString.	^self</body><body package="SpTimes">printOn: aStream 	self asISO8610StringOn: aStream.	^self</body></methods><methods><class-id>SpDate</class-id> <category>services</category><body package="SpTimes">addDays: anInteger 	"^an OSkDateI don't change the date I represent.  Rather, I create a new date which represents my date offset by anInteger days."	^SpDate fromDays: self asDays + anInteger</body><body package="SpTimes">addYears: anInteger	"^an OSkDateI don't change the date I represent.  Rather, I create a new date which represents my date offset by anInteger years.  If we are adding years to the 29th Feb, we need to worry about leap years. "		| newYear newDayNumber |	newYear := self underlyingDate year + anInteger.	newDayNumber := (self underlyingDate monthIndex == 2		and: [self underlyingDate dayOfMonth == 29])		ifTrue:			[(self class isLeapYear: newYear)				ifTrue: [29]				ifFalse: [28]]		ifFalse: [self underlyingDate dayOfMonth].	^SpDate		onDate:			(Date				newDay: newDayNumber				monthNumber: self underlyingDate monthIndex				year: newYear)</body><body package="SpTimes">julianDay"^an IntegerI return my julian day number.  Jan 1st is 1."	^self underlyingDate dayOfYear</body><body package="SpTimes">monthDay	"^an IntegerI return the integer day number within the month.  The first of the month is 1."		^self underlyingDate dayOfMonth</body><body package="SpTimes">monthNumber	"^an IntegerI return the integer number of the month.  January is 1, December is 12."		^self underlyingDate monthIndex</body></methods><methods><class-id>SpDate</class-id> <category>accessing</category><body package="SpTimes">underlyingDate	^underlyingDate</body></methods><methods><class-id>SpDate class</class-id> <category>instanceCreation</category><body package="SpTimes">fromDays: anInteger	^self new onDate: (Date fromDays: anInteger)</body><body package="SpTimes">fromISO8610Stream: aStream 	| date |	date := SpExceptionContext 				for: [self parseDateFromISO8601Stream: aStream]				on: SpError				do: [:ex | nil].	^date isNil ifTrue: [nil] ifFalse: [self onDate: date]</body><body package="SpTimes">fromISO8610String: aString 	^aString size == 10 		ifFalse: [nil]		ifTrue: [self fromISO8610Stream: aString readStream]</body><body package="SpTimes">onDate: aDate	^self new onDate: aDate</body><body package="SpTimes">today	^self onDate: Date today</body></methods><methods><class-id>SpDate class</class-id> <category>private</category><body package="SpTimes">integerOfLength: aLength FromString: aString 	"^an Integer or nil	I parse an integer from aString, if I have problems I return nil.  I make sure	the string form of the integer is exactly aLength characters long."	"OSkDate integerOfLength: 4 FromString: '2004'"	^(aString size == aLength and: 			[(aString asOrderedCollection select: [:aDigit | aDigit isDigit not]) 				isEmpty]) 		ifFalse: [nil]		ifTrue: [aString asNumber]</body><body package="SpTimes">parseDateFromISO8601Stream: sourceStream 	"^a Date or nil	I parse an ISO 8601 date from sourceStream.  If there are any parsing	problems, I return nil."	| yyyy mm dd |	yyyy := self integerOfLength: 4 FromString: (sourceStream upTo: $-).	mm := self integerOfLength: 2 FromString: (sourceStream upTo: $-).	dd := self integerOfLength: 2 FromString: (sourceStream next: 2).	(yyyy isNil or: [mm isNil or: [dd isNil]]) ifTrue: [^nil].	^SpExceptionContext 		for: 			[Date 				newDay: dd				monthNumber: mm				year: yyyy]		on: GenericException		do: [:ex | nil]</body></methods><methods><class-id>SpDate class</class-id> <category>services</category><body package="SpTimes">isLeapYear: anInteger		^anInteger \\ 4 = 0 and: [anInteger \\ 100 &gt; 0 or: [anInteger \\ 400 = 0]]</body></methods><methods><class-id>SpExceptionContext class</class-id> <category>native exceptions</category><body package="SpExceptions">brokenPipeException	"I return the exception that get's thrown when a socket connection gets 	broken."	^OsTransferFaultError</body></methods><methods><class-id>SpExceptionContext class</class-id> <category>instance creation</category><body package="SpExceptions">for: aBlock on: anException do: exceptionBlock 	"^an Object 	I return the result of evaluating aBlock. In VisualWorks and other 	Smalltalks which are ANSI compliant, I delegate to aBlock."	^aBlock on: anException do: exceptionBlock</body><body package="SpExceptions">for: aBlock onAnyErrorDo: exceptionBlock 	"^an Object 	I execute aBlock and if there is any error I evaluate exceptionBlock."	^aBlock on: Error do: exceptionBlock</body><body package="SpExceptions">for: aBlock onAnyExceptionDo: exceptionBlock 	"^an Object 	I execute aBlock and if there is any exception I evaluate exceptionBlock.  Essentially, I look out for the most abstract kind of exception which , of course, will vary between Smalltalk implementations."	^aBlock on: Exception do: exceptionBlock</body></methods><methods><class-id>SpTimesCodeForSqueak class</class-id> <category>code strings</category><body package="SpTimes">codeString	"^a String	I return the string which is the source code for the OpenSkills GemStone time classes."	"(Filename named: 'SpTimes-squeak.st') writeStream nextPutAll: self codeString; close"	^'Object subclass: #SpDate	instanceVariableNames: ''underlyingDate''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpTimes''!!SpDate methodsFor: ''services'' stamp: ''BB 1/25/2006 15:47''!addDays: anInteger 	"^an OSkDateI don''t change the date I represent.  Rather, I create a new date which represents my date offset by anInteger days."	^SpDate fromDays: self asDays + anInteger! !!SpDate methodsFor: ''services'' stamp: ''BB 1/25/2006 15:47''!addYears: anInteger 	"^an OSkDateI don''t change the date I represent.  Rather, I create a new date which represents my date offset by anInteger years."	^SpDate onDate: (Date 				newDay: self underlyingDate dayOfMonth				monthNumber: self underlyingDate monthIndex				year: self underlyingDate year + anInteger)! !!SpDate methodsFor: ''printing'' stamp: ''BB 1/25/2006 15:46''!asISO8610String 	|targetStream|	targetStream := WriteStream on: String new.	self asISO8610StringOn: targetStream.	^targetStream contents! !!SpDate methodsFor: ''printing'' stamp: ''BB 1/25/2006 15:46''!asISO8610StringOn: aStream 	aStream		nextPutAll: self underlyingDate year printString;		nextPut: $-.	self underlyingDate monthIndex &lt; 10 ifTrue: [aStream nextPut: $0].	aStream		nextPutAll: self underlyingDate monthIndex printString;		nextPut: $-.	self underlyingDate dayOfMonth &lt; 10 ifTrue: [aStream nextPut: $0].	aStream nextPutAll: self underlyingDate dayOfMonth printString.	^self! !!SpDate methodsFor: ''converting'' stamp: ''BB 1/25/2006 15:45''!asDays	"^an Integer	I return the integer number of days between January 1, 1901 and	the date I represent. "	^self underlyingDate asDays! !!SpDate methodsFor: ''comparing'' stamp: ''BB 1/25/2006 15:45''!hash	"^an Object"	^self underlyingDate hash! !!SpDate methodsFor: ''comparing'' stamp: ''BB 1/25/2006 15:44''!&lt; anotherOSkDate 	"^a Boolean	Answer true if anotherOSkDate is less (i.e. earlier) than me."	^self underlyingDate &lt; anotherOSkDate underlyingDate! !!SpDate methodsFor: ''comparing'' stamp: ''BB 1/25/2006 15:45''!= anotherOSkDate 	"^a Boolean	Answer true if anotherOSkDate is equivalent to me."	^self underlyingDate = anotherOSkDate underlyingDate! !!SpDate methodsFor: ''comparing'' stamp: ''BB 1/25/2006 15:45''!&gt; anotherOSkDate 	"^a Boolean	Answer true if anotherOSkDate is greater (i.e. later) than me."	^self underlyingDate &gt; anotherOSkDate underlyingDate! !!SpDate methodsFor: ''accessing'' stamp: ''BB 1/25/2006 15:37''!underlyingDate	^underlyingDate! !!SpDate methodsFor: ''initialize-release'' stamp: ''BB 1/25/2006 15:36''!onDate: aDate 	underlyingDate := aDate.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SpDate class	instanceVariableNames: ''''!!SpDate class methodsFor: ''prvate'' stamp: ''BB 1/25/2006 15:35''!integerOfLength: aLength FromString: aString 	"^an Integer or nil	I parse an integer from aString, if I have problems I return nil.  I make sure	the string form of the integer is exactly aLength characters long."	"OSkDate integerOfLength: 4 FromString: ''2004''"	^(aString size == aLength and: 			[(aString asOrderedCollection select: [:aDigit | aDigit isDigit not]) 				isEmpty]) 		ifFalse: [nil]		ifTrue: [aString asNumber]! !!SpDate class methodsFor: ''prvate'' stamp: ''BB 1/25/2006 15:35''!parseDateFromISO8601Stream: sourceStream 	"^a Date or nil	I parse an ISO 8601 date from sourceStream.  If there are any parsing	problems, I return nil." 	| yyyy mm dd |	yyyy := self integerOfLength: 4 FromString: (sourceStream upTo: $-).	mm := self integerOfLength: 2 FromString: (sourceStream upTo: $-).	dd := self integerOfLength: 2 FromString: (sourceStream next: 2).	(yyyy isNil or: [mm isNil or: [dd isNil]]) ifTrue: [^nil].	^SpExceptionContext 		for: 			[Date 				newDay: dd				monthNumber: mm				year: yyyy]		on: SpError		do: [:ex | nil]! !!SpDate class methodsFor: ''instance creation'' stamp: ''BB 1/25/2006 15:33''!fromDays: anInteger	^self new onDate: (Date fromDays: anInteger)! !!SpDate class methodsFor: ''instance creation'' stamp: ''BB 1/25/2006 15:35''!fromISO8610Stream: aStream 	| date |	date := SpExceptionContext 				for: [self parseDateFromISO8601Stream: aStream]				on: SpError				do: [:ex | nil].	^date isNil ifTrue: [nil] ifFalse: [self onDate: date]! !!SpDate class methodsFor: ''instance creation'' stamp: ''BB 1/25/2006 15:36''!fromISO8610String: aString 	^aString size == 10 		ifFalse: [nil]		ifTrue: [self fromISO8610Stream: aString readStream]! !!SpDate class methodsFor: ''instance creation'' stamp: ''BB 1/25/2006 15:36''!onDate: aDate	^self new onDate: aDate! !!SpDate class methodsFor: ''instance creation'' stamp: ''BB 1/25/2006 15:36''!today	^self onDate: Date today! !Object subclass: #SpTimestamp	instanceVariableNames: ''underlyingTimestamp''	classVariableNames: ''''	poolDictionaries: ''''	category: ''SpTimes''!!SpTimestamp methodsFor: ''private'' stamp: ''BB 1/25/2006 15:29''!underlyingTimestamp	^underlyingTimestamp! !!SpTimestamp methodsFor: ''services'' stamp: ''BB 1/25/2006 15:31''!asRFC1123String	"^a String	c.f  &gt;&gt;asRFC1123StringOn: "	| targetStream |	targetStream := String new writeStream.	self asRFC1123StringOn: targetStream.	^targetStream contents! !!SpTimestamp methodsFor: ''services'' stamp: ''BB 1/29/2006 21:11''!asRFC1123StringOn: targetStream 	"^self	Code taken from Swazoo Timestamp extenton with the following 	comment: FIXME: Assumes server''s clock is GMT. Should convert server''s	clock to GMT if it is not. Besides that, this whole method is really ugly."	targetStream		nextPutAll: (self underlyingTimestamp asDate weekday copyFrom: 1 to: 3);		 nextPutAll: '', ''.	self underlyingTimestamp day &lt; 10		ifTrue: [targetStream nextPut: $0].	self underlyingTimestamp asDate printOn: targetStream format: #(1 2 3 $  2 1 ).	targetStream space.	self underlyingTimestamp printHMSOn: targetStream.	targetStream nextPutAll: '' GMT''! !!SpTimestamp methodsFor: ''services'' stamp: ''BB 1/25/2006 15:31''!asSeconds	"^an IntegerI return the timestamp as a number of seconds."	^self underlyingTimestamp asSeconds! !!SpTimestamp methodsFor: ''comparing'' stamp: ''BB 1/25/2006 15:30''!hash	^self underlyingTimestamp hash! !!SpTimestamp methodsFor: ''comparing'' stamp: ''BB 1/25/2006 15:28''!&lt;= anOSkTimeStamp 	^self underlyingTimestamp &lt;= anOSkTimeStamp underlyingTimestamp! !!SpTimestamp methodsFor: ''comparing'' stamp: ''BB 1/25/2006 15:29''!= anOSkTimeStamp^self underlyingTimestamp = anOSkTimeStamp underlyingTimestamp! !!SpTimestamp methodsFor: ''comparing'' stamp: ''BB 1/25/2006 15:30''!&gt; anOSkTimeStamp^self underlyingTimestamp &gt; anOSkTimeStamp underlyingTimestamp! !!SpTimestamp methodsFor: ''initialize-release'' stamp: ''BB 1/25/2006 15:27''!asNowUTC	"^selfCheat for now and assumen that Timestamp&gt;&gt;now is UTC."	underlyingTimestamp := TimeStamp now.	^self! !!SpTimestamp methodsFor: ''initialize-release'' stamp: ''BB 1/25/2006 15:27''!fromDate: aDate andTime: aTime 	"^selfInitialize myself on the basis of aDate and aTime."	underlyingTimestamp := TimeStamp fromDate: aDate andTime: aTime.	^self! !!SpTimestamp methodsFor: ''initialize-release'' stamp: ''BB 1/25/2006 15:28''!fromSeconds: anInteger 	"^an OSkTimestampI return an instance of myself that represents anInteger number of seconds since January 1, 1901 0:00:00.000.  BTW, negative values of anInteger are fine."	underlyingTimestamp := TimeStamp fromSeconds: anInteger.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SpTimestamp class	instanceVariableNames: ''''!!SpTimestamp class methodsFor: ''instance creation'' stamp: ''BB 1/25/2006 15:26''!fromDate: aDate andTime: aTime 	^self new fromDate: aDate andTime: aTime! !!SpTimestamp class methodsFor: ''instance creation'' stamp: ''BB 1/25/2006 15:26''!fromRFC1123String: aString 	"^an OSkTimestamp"	| sourceStream dd mmm yyyy time |	^SpExceptionContext for: 			[sourceStream := ReadStream on: aString.			sourceStream upTo: Character space.			dd := sourceStream upTo: Character space.			mmm := sourceStream upTo: Character space.			yyyy := sourceStream upTo: Character space.			time := sourceStream upTo: Character space.			self fromDate: (Date 						newDay: dd asNumber						month: mmm						year: yyyy asNumber)				andTime: (Time readFrom: (ReadStream on: time))]		onAnyExceptionDo: 			[:exception | 			SpError raiseSignal: ''Error parsing RFC1123 date: '' , aString]! !!SpTimestamp class methodsFor: ''instance creation'' stamp: ''BB 1/25/2006 15:26''!fromSeconds: anInteger 	"^an OSkTimestampI return an instance of myself that represents anInteger number of seconds since ..."	^self new fromSeconds: anInteger! !!SpTimestamp class methodsFor: ''instance creation'' stamp: ''BB 1/25/2006 15:26''!now	"^an OSkTimestamp	I return a new instance of myself which represents the time now in the	UTC (GMT ish) time zone."	^self new asNowUTC! !'</body></methods><methods><class-id>SpNonBlockingSocketReadRequestPreCake</class-id> <category>services-io</category><body package="SpSockets">recvInto: aByteArray startingAt: startIndex for: aNumberOfOctets 	^self doThenComplete: 			[| currentResponse |			currentResponse := self underlyingSocket 						primNofailReadInto: aByteArray						startingAt: startIndex						for: aNumberOfOctets.			currentResponse isNil ifTrue: [currentResponse := -1].			^currentResponse &gt; 0 				ifTrue: [currentResponse]				ifFalse: 					[currentResponse &lt; 0 						ifTrue: 							[(SocketAccessor restartableError: self underlyingSocket errorCode) 								ifTrue: [0]								ifFalse: 									[socket close.									SpSocketError signalWith: (self underlyingSocket class												errorSymbolFor: self underlyingSocket errorCode)]]						ifFalse: 							[socket close.							SpSocketShutDownByPeer raiseSignal]]]</body></methods><methods><class-id>SpExceptionCodeForGemStone class</class-id> <category>code strings</category><body package="SpExceptions">codeString	"	***This is decompiled code.*** 	This may reflect a problem with the configuration of your image and its 	sources and changes files. 	Please refer to the documentation and the settings tool for help in setting up 	the proper source code files."	^'!! From ! GEMSTONE: 6.1, Thu Apr 17 20:11:38 US/Pacific 2003; IMAGE: GemStone v6.1 kernel classes filein completed at 17/04/2003 20:22:36! GemStone v6.1 kernel classes filein of stripped sources completed at 17/04/2003 20:31:50! ! On August 17, 2007, 1:30:49 am!!! SymbolDictionary ''SpExceptions''!run| symList newDict |symList := System myUserProfile symbolList.symList do: [ :element |    (element includesKey: #SpExceptions)        ifTrue: [ ^element ]].newDict := SymbolDictionary new.newDict at: #SpExceptions put: newDict.System myUserProfile insertDictionary: newDict at: 1.^newDict%doit(Object subclass: ''SpAbstractError''  instVarNames: #( handler gsCategory gsSignalNumber                    gsArguments messageText parameter)  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpExceptions  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(SpAbstractError subclass: ''SpError''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpExceptions  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(SpError subclass: ''SpAnyGemStoneError''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpExceptions  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(SpError subclass: ''SpStreamError''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpExceptions  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''SpExceptionContext''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpExceptions  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''SpExceptionTests''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: SpExceptions  constraints: #[]  instancesInvariant: false  isModifiable: true).%doitSpAbstractError immediateInvariant.%doitSpError immediateInvariant.%doitSpAnyGemStoneError immediateInvariant.%doitSpStreamError immediateInvariant.%doitSpExceptionContext immediateInvariant.%doitSpExceptionTests immediateInvariant.%! Remove existing behavior from SpAbstractErrordoitSpAbstractError removeAllMethods.SpAbstractError class removeAllMethods.%! ------------------- Class methods for SpAbstractErrorcategory: ''accessing''classmethod: SpAbstractErrorexceptionCategory	"^a LanguageDictionaryI return the SpExceptionCategory - I create it if necessary.   An exception category is always an insance of LanguageDictionary (yes, really).  LanguageDictionaries are just SymbolDictionaries keyed on symbols which are language names, e.g. #English.  We have an English entry, which has a value of an array.  This array represents the exception numbers and the text to be displayed when the exception is raised.  We have just one exception number, and the text to be displayed is the result of sending &gt;&gt;asString to the first elemnt of the arguments created when the exception is raised - so we have an Array with one element (the number 1) at index 1 of the Array of errors in English.  Phew.  See the GemStone Programming Guide is you really want to understand GemStone exceptions."	^SpExceptions at: #SpExceptionCategory		ifAbsentPut: 			[(LanguageDictionary new)				at: #English put: (Array with: #(1));				yourself]%category: ''accessing''classmethod: SpAbstractErrorsignalNumber"^an IntegerAll Sp Exceptions use the signal number 1.  They are then differenciated by class, per ANSI."	^1%category: ''raising''classmethod: SpAbstractErrorraise: anException	"^a SpErrorI raise anException which should be one of my instances.  Here in GemStone (until ANSI exceptions) we have to signal exceptions using System&gt;&gt;signal ...""	^System 		signal: 1		args: (Array with: anException messageText)		signalDictionary: self exceptionCategory""I think the above should work - but it doesn''t :-( "^self raiseSignal: anException messageText%category: ''raising''classmethod: SpAbstractErrorraiseSignal	"^a SpErrorI raise an exception with no specific message."	^self raiseSignal: nil%category: ''raising''classmethod: SpAbstractErrorraiseSignal: aString 	"^a SpErrorI raise an exception.  Here in GemStone (until ANSI exceptions) we have to signal exceptions using System&gt;&gt;signal ..."	| arguments |	arguments := OrderedCollection with: self new.	aString notNil ifTrue: [arguments add: aString].	^System 		signal: 1		args: arguments asArray		signalDictionary: self exceptionCategory%category: ''testing''classmethod: SpAbstractErrormayResume	"^a Boolean	By default exceptions may not resume.  My subclasses may override."	^false%! ------------------- Instance methods for SpAbstractErrorcategory: ''accessing''method: SpAbstractErrorarguments	"^an ArrayI return the arguments array for the exception I represent."	^(Array new: 2) 		at: 1 put: self class;		at: 2 put: self messageText;"		at: 3 put: self parameter; "		yourself%category: ''accessing''method: SpAbstractErrorarguments: anArray	"^selfThe arguments array contains my class as the first element, then optionally a message text, and lastly a parameter."	self gsArguments: anArray.	anArray size &gt; 1 ifTrue: [self messageText: (anArray at: 2)].	anArray size &gt; 2 ifTrue: [self parameter: (anArray at: 3)].	^self%category: ''accessing''method: SpAbstractErrorexceptionCategory	^self class exceptionCategory%category: ''accessing''method: SpAbstractErrorgsArguments	^gsArguments%category: ''accessing''method: SpAbstractErrorgsArguments: anArgumentsArray	gsArguments := anArgumentsArray.	^self%category: ''accessing''method: SpAbstractErrorgsCategory	^gsCategory%category: ''accessing''method: SpAbstractErrorgsCategory: aGemStoneExceptionCategory	gsCategory := aGemStoneExceptionCategory.	^self%category: ''accessing''method: SpAbstractErrorgsSignalNumber	^gsSignalNumber%category: ''accessing''method: SpAbstractErrorgsSignalNumber: aGemStoneExceptionSignalNumber	gsSignalNumber := aGemStoneExceptionSignalNumber.	^self%category: ''accessing''method: SpAbstractErrorhandler	"^selfI return my handler."		^handler%category: ''accessing''method: SpAbstractErrorhandler: aHandler	"^selfI record the handler here, just in case"		handler := aHandler.	^self%category: ''accessing''method: SpAbstractErrormessageText	"^a String I return the text of the error message."	^messageText%category: ''accessing''method: SpAbstractErrormessageText: aString	"^self I record the text of the error message."	messageText := aString.	^self%category: ''accessing''method: SpAbstractErrorparameter	"^self I return the parameter for this exception."	^parameter%category: ''accessing''method: SpAbstractErrorparameter: anObject	"^self I record the parameter for this exception."	parameter := anObject.	^self%category: ''accessing''method: SpAbstractErrorsignalNumber	^self class signalNumber%category: ''license''method: SpAbstractErrorlicense	"^a License 	Copyright 2004 Bruce Badger	This software is licenced under the LGPL."	^nil%category: ''services''method: SpAbstractErrorinitialContext"^selfI''m not sure what the equivalent of the VW &gt;&gt;initialContext is in GemStone."	^self%category: ''services''method: SpAbstractErrorpass"^selfIf I have an active handler, I use &gt;&gt;resignal to pass the exception *as I originaly received it* to the next outer handler.If you end up here because of a &gt;&gt;halt, put a breakpoint in SpExceptionContext class&gt;&gt;doCatchingAnything: where the Sp exception instance is created ... then you will see where the halt *really* is.  Any suggestions on how to do this properly in GemStone would be most welcome."	self handler isNil ifFalse: [		self handler			resignal: self gsCategory			number: self gsSignalNumber			args: self gsArguments].	^self	%category: ''services''method: SpAbstractErrorraise"^selfIf an exception class is resumable, I don''t actually raise the exception at all for now.  Ugh.  This is because I can''t work out how to get the GemStone exceptions to resume nicely."	#wip yourself.	^self class mayResume		ifTrue: [self]		ifFalse: [self class raise: self].%category: ''services''method: SpAbstractErrorresume	"^selfThis has no meaning with GemStone exceptions.  I don''t know what to do here, and doing nothing could cause problems (like corruption, even) so I raise an ''Uncontinuable Error'' (see the last page of the Error Handling section of the GemStone programming guide."	self class mayResume 		ifFalse: 			[System 				signal: (ErrorSymbols at: #rtErrUncontinuable)				args: #()				signalDictionary: GemStoneError].	^self%category: ''testing''method: SpAbstractErrorisNoticeResponse	"^a Boolean 	I return true if I am a notice response, otherwise, I return false. By default, I return false."	^false%! Remove existing behavior from SpErrordoitSpError removeAllMethods.SpError class removeAllMethods.%! ------------------- Class methods for SpError! ------------------- Instance methods for SpError! Remove existing behavior from SpAnyGemStoneErrordoitSpAnyGemStoneError removeAllMethods.SpAnyGemStoneError class removeAllMethods.%! ------------------- Class methods for SpAnyGemStoneErrorcategory: ''accessing''classmethod: SpAnyGemStoneErrorsignalNumber"^an IntegerI return my unique GemStone signal number."	^nil%! ------------------- Instance methods for SpAnyGemStoneError! Remove existing behavior from SpStreamErrordoitSpStreamError removeAllMethods.SpStreamError class removeAllMethods.%! ------------------- Class methods for SpStreamError! ------------------- Instance methods for SpStreamError! Remove existing behavior from SpExceptionContextdoitSpExceptionContext removeAllMethods.SpExceptionContext class removeAllMethods.%! ------------------- Class methods for SpExceptionContextcategory: ''instance creation''classmethod: SpExceptionContextfor: aBlock on: anExceptionClass do: exceptionBlock 	"^an ObjectI run aBlock in &gt;&gt;do:catchExceptionsOfClass: and either get a result of an exception of anExceptionClass (or subclass) or some other object.  If the result is some other object, I return it.  Otherwise I return the result of evaluating exceptionBlock."	| result |	result := self do: aBlock catchExceptionsOfClass: anExceptionClass.	^(result isKindOf: anExceptionClass) 		ifTrue: [exceptionBlock value: result]		ifFalse: [result]%category: ''instance creation''classmethod: SpExceptionContextfor: aBlock onAnyExceptionDo: exceptionBlock 	"^an Object 	I execute aBlock and if there is any exception I evaluate exceptionBlock.  Essentially, I look out for the most abstract kind of exception which , of course, will vary between Smalltalk implementations."	| result |	result := self doCatchingAnything: aBlock .	^(result isKindOf: SpAbstractError) 		ifTrue: [exceptionBlock value: result]		ifFalse: [result]%category: ''native exceptions''classmethod: SpExceptionContextbrokenPipeException	"I return the exception that get''s thrown when a socket connection gets 	broken. This is used in PostgreSQLConnection&gt;&gt;close."	^SpAnyGemStoneError%category: ''private''classmethod: SpExceptionContextdo: aBlock catchExceptionsOfClass: anExceptionClass 	"^an ObjectThe objective is to execute aBlock.  If there is an exception which is a kind of anExceptionClass I catch it, and see if the exception raised is either anExceptionClass or one of its subclasses.  If it is, I return the exception from the block which will cause some exception handling code to be run (see my sender)."	Exception 		category: SpAbstractError exceptionCategory		number: nil		do: 			[:exceptionHandler :category :signalNumber :exceptionArguments | 			| anException |			(exceptionArguments notEmpty 				and: [(anException := exceptionArguments at: 1) isKindOf: anExceptionClass]) 					ifTrue: 						[anException							handler: exceptionHandler;							gsCategory: category;							gsSignalNumber: signalNumber;								arguments: exceptionArguments.						^anException]					ifFalse: 						[exceptionHandler 							resignal: category							number: signalNumber							args: exceptionArguments]].	^aBlock value%category: ''private''classmethod: SpExceptionContextdoCatchingAnything: aBlock 	"^an ObjectThe objective is to execute aBlock.  If there is any exception I catch it and return an SpAbscractError exception from the block which will cause some exception handling code to be run (see my sender)."	Exception 		category: nil		number: nil		do: 			[:exceptionHandler :category :signalNumber :exceptionArguments | 			| anException |			anException := SpAbstractError new.			anException				handler: exceptionHandler;				gsCategory: category;				gsSignalNumber: signalNumber;				arguments: exceptionArguments.			^anException].	^aBlock value%! ------------------- Instance methods for SpExceptionContext! Remove existing behavior from SpExceptionTestsdoitSpExceptionTests removeAllMethods.SpExceptionTests class removeAllMethods.%! ------------------- Class methods for SpExceptionTestscategory: ''testing''classmethod: SpExceptionTeststest01	"Just throw an exception"	"SpExceptionTests test01"	^SpError raiseSignal%category: ''testing''classmethod: SpExceptionTeststest02	"Catch an exception"	"SpExceptionTests test02"	SpExceptionContext 		for: [self test01]		on: SpError		do: [:ex| ex halt]%category: ''testing''classmethod: SpExceptionTeststest03	"Raise an exception raised in a handle block"	"SpExceptionTests test03"	SpExceptionContext 		for: [self test01]		on: SpError		do: [:ex| self test01]%category: ''testing''classmethod: SpExceptionTeststest04	"Catch an exception raised in a handle block"	"SpExceptionTests test04"	SpExceptionContext 		for: [self test03]		on: SpError		do: [:ex| ex halt]%category: ''testing''classmethod: SpExceptionTeststest05	"Catch an exception by secifying a superclass of the raised exception class."	"SpExceptionTests test05"	SpExceptionContext 		for: [self test01]		on: SpAbstractError		do: [:ex| ex halt]%! ------------------- Instance methods for SpExceptionTests'</body></methods><methods><class-id>SpBlockingSocketReadRequest</class-id> <category>services-io</category><body package="SpSockets">read: targetNumberOfBytes 	"^a ByteArray	I attempt to read the targetNumberOfBytes from the underlying socket.  If the targetNumberOfBytes	are not available, I return what I can get."	^self doThenComplete: 			[SpExceptionContext 				for: 					[| targetByteArray numberOfBytesActuallyRead |					targetByteArray := ByteArray new: targetNumberOfBytes.					numberOfBytesActuallyRead := self underlyingSocket 								readInto: targetByteArray.					targetByteArray copyFrom: 1 to: numberOfBytesActuallyRead]				on: Error				do: [:ex | SpSocketError signalWith: ex]]</body><body package="SpSockets">readyForRead	"^a BooleanI return true if a read operation will return some number of bytes."	^self doThenComplete: [self underlyingSocket bytesForRead &gt; 0]</body><body package="SpSockets">recvInto: aByteArray startingAt: startIndex for: aNumberOfBytes 	"^an IntegerI return the number of bytes actually read.  This call will block waiting for activity on the socket.  If the number of octets read is zero, this means that the peer has performed an orderly shutdown of the socket and in this case I raise an exception.  c.f. the man page for recv()"	^self doThenComplete: 			[| numberOfOctetsActuallyRead |			numberOfOctetsActuallyRead := self underlyingSocket 						readInto: aByteArray						startingAt: startIndex						for: aNumberOfBytes.			numberOfOctetsActuallyRead isZero 				ifTrue: 					[self close.					SpSocketShutDownByPeer raiseSignal].			numberOfOctetsActuallyRead]</body><body package="SpSockets">waitForReadDataUpToMs: aNumberOfMilliseconds 	"^a Boolean	I return true if we think data became available within aNumberOfMilliseconds, and	false if we timed out.	Martin Kobetic on the vwnc list said that getting a successful read wait but finding	no bytes available to read means that the remote end closed the socket - so in this	case I now raise an exception."	^self doThenComplete: 			[| readWaitSuccessful |			readWaitSuccessful := (self underlyingSocket 						readWaitWithTimeoutMs: aNumberOfMilliseconds) not.			readWaitSuccessful 				ifTrue: 					[self readyForRead 						ifTrue: [self socket resetSumOfStalledTime]						ifFalse: 							[self socket incrementSumOfStalledTimeBy: aNumberOfMilliseconds.							self socket sumOfStalledTime &gt; self socket stalledTimeCeiling 								ifTrue: 									[self close.									SpSocketError raiseSignal: 'Socket unexpectedly closed by other end!']								ifFalse: [(Delay forMilliseconds: aNumberOfMilliseconds) wait]]]				ifFalse: [self socket resetSumOfStalledTime].			readWaitSuccessful]</body></methods><methods><class-id>SpFileStream</class-id> <category>services</category><body package="SpFiles">atEnd	^self underlyingStream atEnd</body><body package="SpFiles">close	^self underlyingStream close</body><body package="SpFiles">closed	^self underlyingStream closed</body><body package="SpFiles">contents	^self underlyingStream contents</body><body package="SpFiles">cr	^self underlyingStream cr</body><body package="SpFiles">flush	^self underlyingStream flush</body><body package="SpFiles">next	^self underlyingStream next</body><body package="SpFiles">nextPut: anObject 	^self underlyingStream nextPut: anObject</body><body package="SpFiles">nextPutAll: aCollection 	^self underlyingStream nextPutAll: aCollection</body><body package="SpFiles">peek	^self underlyingStream peek</body><body package="SpFiles">position	^self underlyingStream position</body><body package="SpFiles">position: aNumber	^self underlyingStream position: aNumber</body><body package="SpFiles">skip: anInteger	^self underlyingStream skip: anInteger</body><body package="SpFiles">store: anObject 	^self underlyingStream store: anObject</body><body package="SpFiles">throughAll: aCollection	^self underlyingStream throughAll: aCollection</body><body package="SpFiles">upTo: anObject	^self underlyingStream upTo: anObject</body><body package="SpFiles">upToAll: aCollection	^self underlyingStream upToAll: aCollection</body><body package="SpFiles">upToEnd	^self underlyingStream upToEnd</body></methods><methods><class-id>SpFileStream</class-id> <category>initialize-release</category><body package="SpFiles">appendingToFilename: anOSkFilename 	filename := anOSkFilename asString.	underlyingStream := anOSkFilename underlyingFilename appendStream.	underlyingStream lineEndTransparent.	^self</body><body package="SpFiles">readingFromFilename: anOSkFilename 	filename := anOSkFilename asString.	underlyingStream := anOSkFilename underlyingFilename readStream.	underlyingStream lineEndTransparent.	^self</body><body package="SpFiles">readingFromFileNamed: aString 	"^selfI initialize myself to write to a file named aString."	filename := aString.	underlyingStream := (Filename named: aString) readStream.	underlyingStream lineEndTransparent.	^self</body><body package="SpFiles">writingToFilename: anOSkFilename 	filename := anOSkFilename asString.	underlyingStream := anOSkFilename underlyingFilename writeStream.	underlyingStream lineEndTransparent.	^self</body><body package="SpFiles">writingToFileNamed: aString 	"^selfI initialize myself to write to a file named aString."	filename := aString.	underlyingStream := (Filename named: aString) writeStream.	underlyingStream lineEndTransparent.	^self</body></methods><methods><class-id>SpFileStream</class-id> <category>accessing</category><body package="SpFiles">contentsStream	^self underlyingStream contents readStream</body><body package="SpFiles">filename	^filename</body><body package="SpFiles">filename: anObject	filename := anObject</body><body package="SpFiles">underlyingStream	^underlyingStream</body></methods><methods><class-id>SpFileStream class</class-id> <category>instance creation</category><body package="SpFiles">appendingToFilename: anOSkFilename 	"^an OSkFileStreamI create a new instance of myself to append to the file identified by anOSkFilename."	^self new appendingToFilename: anOSkFilename</body><body package="SpFiles">readingFromFilename: anOSkFilename 	"^an OSkFileStreamI create a new instance of myself to read the file identified by anOSkFilename."	^self new readingFromFilename: anOSkFilename</body><body package="SpFiles">readingFromFileNamed: aString 	"^an OSkFileStreamI create a new instance of myself to read from a file named aString."	^self new readingFromFileNamed: aString</body><body package="SpFiles">writingToFilename: anOSkFilename 	"^an OSkFileStreamI create a new instance of myself to append to the file identified by anOSkFilename."	^self new writingToFilename: anOSkFilename</body><body package="SpFiles">writingToFileNamed: aString 	"^an OSkFileStreamI create a new instance of myself to write to a file named aString."	^self new writingToFileNamed: aString</body></methods><methods><class-id>SpStringUtilities class</class-id> <category>services</category><body package="SpEnvironmental">prevIndexOf: anElement from: startIndex to: stopIndex in: aString	"Answer the previous index of anElement within the receiver between startIndex and stopIndex	 working backwards through the receiver.  If the receiver does not contain anElement, answer nil"	startIndex to: stopIndex by: -1 do:		[:i |		(aString at: i) = anElement			ifTrue: [^i]].	^nil</body><body package="SpEnvironmental">tokensBasedOn: separatorString in: aString 	"Answer an OrderedCollection of the sub-sequences	 of the receiver that are separated by anObject."	| result lastIdx idx lastToken |	result := OrderedCollection new.	aString size = 0 ifTrue: [^result].	lastIdx := 0.		[idx := aString findString: separatorString startingAt: lastIdx + 1.	idx &gt; 0] 			whileTrue: 				[idx == (lastIdx + 1) 					ifTrue: [result addLast: String new]					ifFalse: [result addLast: (aString copyFrom: lastIdx + 1 to: idx - 1)].				lastIdx := idx].	lastToken := lastIdx = aString size 				ifTrue: [String new]				ifFalse: [aString copyFrom: lastIdx + 1 to: aString size].	result addLast: lastToken.	^result</body><body package="SpEnvironmental">trimBlanksFrom: aString 	"^a StringI return a copy of aString with all leading and trailing blanks removed."	| first last |	first := 1.	last := aString size.	[last &gt; 0 and: [(aString at: last) isSeparator]] 		whileTrue: [last := last - 1].	^last == 0 		ifTrue: [String new]		ifFalse: 			[[first &lt; last and: [(aString at: first) isSeparator]] 				whileTrue: [first := first + 1].			aString copyFrom: first to: last]</body></methods><methods><class-id>SpStringUtilities class</class-id> <category>services-encoding</category><body package="SpEnvironmental">bytes: subjectBytes asStringUsingEncodingNames: anEncodingName 	^subjectBytes asStringEncoding: anEncodingName</body><body package="SpEnvironmental">string: subjectString asBytesUsingEncodingNamed: anEncodingName 	^subjectString asByteArrayEncoding: anEncodingName</body><body package="SpEnvironmental">stringFromBytes: aByteArray 	"^a StringIn GemStone ['Hello, World' asByteArray asString] returns the string 'aByteArray' !This is the boring long way of getting a string from a ByteArray - but it does workin GemStone."	"HTTPString stringFromBytes: ('Hello, World' asByteArray)"	| targetStream |	targetStream := WriteStream on: String new.	aByteArray do: [:aByte | targetStream nextPut: aByte asCharacter].	^targetStream contents</body></methods><initialize><class-id>SpSocket</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UserApplication</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>